#region Notices
// <auto-generated>
// Warning: This file was automatically generated. Changes to this file may
// cause incorrect behavior and will be lost when this file is regenerated.
// </auto-generated>
// <information>
// This file was generated using MetaFac.CG4 tools and user supplied metadata.
// Generator: MessagePack.2.8
// Metadata : MetaFac.CG4.TestOrg.Schema(.BasicTypes)
// </information>
#endregion
#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable CS8019 // Unnecessary using directive
#pragma warning disable CS8019 // Unnecessary using directive
using MetaFac.Memory;
using MetaFac.Mutability;
using MessagePack;
using MetaFac.CG4.Runtime;
using MetaFac.CG4.Runtime.MessagePack;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Numerics;
using System.Runtime.CompilerServices;
using MetaFac.CG4.TestOrg.ModelsNet7.BasicTypes.Contracts;

namespace MetaFac.CG4.TestOrg.ModelsNet7.BasicTypes.MessagePack
{


    public abstract class EntityBase : IFreezable, IEntityBase, IEquatable<EntityBase>, ICopyFrom<EntityBase>
    {
        public static EntityBase Empty => throw new NotSupportedException();
        public const int EntityTag = 0;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static void ThrowIsReadonly()
        {
            throw new InvalidOperationException("Cannot set properties when frozen");
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected ref T CheckNotFrozen<T>(ref T value)
        {
            if (_isFrozen) ThrowIsReadonly();
            return ref value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected void CheckNotFrozen()
        {
            if (_isFrozen) ThrowIsReadonly();
        }

        public EntityBase() { }
        public EntityBase(EntityBase source) { }
        public void CopyFrom(EntityBase source) => CheckNotFrozen();
        public EntityBase(IEntityBase source) { }
        protected abstract int OnGetEntityTag();
        public int GetEntityTag() => OnGetEntityTag();

        protected volatile bool _isFrozen = false;
        public bool IsFreezable() => true;
        public bool IsFrozen() => _isFrozen;
        protected virtual void OnFreeze() { }
        public void Freeze()
        {
            if (_isFrozen) return;
            OnFreeze();
            _isFrozen = true;
        }
        public bool TryFreeze()
        {
            if (_isFrozen) return false;
            OnFreeze();
            _isFrozen = true;
            return true;
        }

        public bool Equals(EntityBase? other) => true;
        public override bool Equals(object? obj) => obj is EntityBase other && this.Equals(other);
        public override int GetHashCode() => 0;
    }


    public sealed class Basic_bool_Factory : IEntityFactory<IBasic_bool, Basic_bool>
    {
        private static readonly Basic_bool_Factory _instance = new Basic_bool_Factory();
        public static Basic_bool_Factory Instance => _instance;

        public Basic_bool? CreateFrom(IBasic_bool? source)
        {
            if (source is null) return null;
            if (source is Basic_bool sibling && sibling.IsFrozen()) return sibling;
            return new Basic_bool(source);
        }

        private static readonly Basic_bool _empty = new Basic_bool().Frozen();
        public Basic_bool Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_bool : EntityBase, IBasic_bool, IEquatable<Basic_bool>, ICopyFrom<Basic_bool>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 1;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Boolean field_ScalarRequired;
        private Boolean? field_ScalarOptional;
        private ImmutableList<Boolean>? field_VectorRequired;
        private ImmutableList<Boolean?>? field_VectorOptional;
        private ImmutableDictionary<String, Boolean>? field_MapRequired;
        private ImmutableDictionary<String, Boolean?>? field_MapOptional;
        private ImmutableDictionary<Boolean, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public Boolean ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Boolean? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<Boolean>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<Boolean?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, Boolean>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, Boolean?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Boolean, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_bool methods ----------
        Boolean IBasic_bool.ScalarRequired => field_ScalarRequired.ToExternal();
        Boolean? IBasic_bool.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Boolean>? IBasic_bool.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Boolean, Boolean>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Boolean?>? IBasic_bool.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Boolean?, Boolean?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Boolean>? IBasic_bool.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Boolean, Boolean>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Boolean?>? IBasic_bool.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Boolean?, Boolean?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Boolean, String?>? IBasic_bool.MapKey => field_MapKey;

        public Basic_bool()
        {
        }

        public Basic_bool(Basic_bool source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_bool source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_bool(IBasic_bool source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<Boolean>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<Boolean?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, Boolean>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, Boolean>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, Boolean?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, Boolean?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Boolean, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_bool? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_bool left, Basic_bool right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_bool left, Basic_bool right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_bool other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_sbyte_Factory : IEntityFactory<IBasic_sbyte, Basic_sbyte>
    {
        private static readonly Basic_sbyte_Factory _instance = new Basic_sbyte_Factory();
        public static Basic_sbyte_Factory Instance => _instance;

        public Basic_sbyte? CreateFrom(IBasic_sbyte? source)
        {
            if (source is null) return null;
            if (source is Basic_sbyte sibling && sibling.IsFrozen()) return sibling;
            return new Basic_sbyte(source);
        }

        private static readonly Basic_sbyte _empty = new Basic_sbyte().Frozen();
        public Basic_sbyte Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_sbyte : EntityBase, IBasic_sbyte, IEquatable<Basic_sbyte>, ICopyFrom<Basic_sbyte>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 2;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private SByte field_ScalarRequired;
        private SByte? field_ScalarOptional;
        private ImmutableList<SByte>? field_VectorRequired;
        private ImmutableList<SByte?>? field_VectorOptional;
        private ImmutableDictionary<String, SByte>? field_MapRequired;
        private ImmutableDictionary<String, SByte?>? field_MapOptional;
        private ImmutableDictionary<SByte, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public SByte ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public SByte? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<SByte>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<SByte?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, SByte>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, SByte?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<SByte, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_sbyte methods ----------
        SByte IBasic_sbyte.ScalarRequired => field_ScalarRequired.ToExternal();
        SByte? IBasic_sbyte.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<SByte>? IBasic_sbyte.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<SByte, SByte>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<SByte?>? IBasic_sbyte.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<SByte?, SByte?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, SByte>? IBasic_sbyte.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, SByte, SByte>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, SByte?>? IBasic_sbyte.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, SByte?, SByte?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<SByte, String?>? IBasic_sbyte.MapKey => field_MapKey;

        public Basic_sbyte()
        {
        }

        public Basic_sbyte(Basic_sbyte source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_sbyte source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_sbyte(IBasic_sbyte source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<SByte>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<SByte?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, SByte>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, SByte>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, SByte?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, SByte?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<SByte, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_sbyte? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_sbyte left, Basic_sbyte right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_sbyte left, Basic_sbyte right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_sbyte other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_byte_Factory : IEntityFactory<IBasic_byte, Basic_byte>
    {
        private static readonly Basic_byte_Factory _instance = new Basic_byte_Factory();
        public static Basic_byte_Factory Instance => _instance;

        public Basic_byte? CreateFrom(IBasic_byte? source)
        {
            if (source is null) return null;
            if (source is Basic_byte sibling && sibling.IsFrozen()) return sibling;
            return new Basic_byte(source);
        }

        private static readonly Basic_byte _empty = new Basic_byte().Frozen();
        public Basic_byte Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_byte : EntityBase, IBasic_byte, IEquatable<Basic_byte>, ICopyFrom<Basic_byte>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 3;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Byte field_ScalarRequired;
        private Byte? field_ScalarOptional;
        private ImmutableList<Byte>? field_VectorRequired;
        private ImmutableList<Byte?>? field_VectorOptional;
        private ImmutableDictionary<String, Byte>? field_MapRequired;
        private ImmutableDictionary<String, Byte?>? field_MapOptional;
        private ImmutableDictionary<Byte, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public Byte ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Byte? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<Byte>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<Byte?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, Byte>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, Byte?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Byte, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_byte methods ----------
        Byte IBasic_byte.ScalarRequired => field_ScalarRequired.ToExternal();
        Byte? IBasic_byte.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Byte>? IBasic_byte.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Byte, Byte>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Byte?>? IBasic_byte.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Byte?, Byte?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Byte>? IBasic_byte.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Byte, Byte>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Byte?>? IBasic_byte.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Byte?, Byte?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Byte, String?>? IBasic_byte.MapKey => field_MapKey;

        public Basic_byte()
        {
        }

        public Basic_byte(Basic_byte source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_byte source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_byte(IBasic_byte source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<Byte>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<Byte?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, Byte>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, Byte>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, Byte?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, Byte?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Byte, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_byte? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_byte left, Basic_byte right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_byte left, Basic_byte right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_byte other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_short_Factory : IEntityFactory<IBasic_short, Basic_short>
    {
        private static readonly Basic_short_Factory _instance = new Basic_short_Factory();
        public static Basic_short_Factory Instance => _instance;

        public Basic_short? CreateFrom(IBasic_short? source)
        {
            if (source is null) return null;
            if (source is Basic_short sibling && sibling.IsFrozen()) return sibling;
            return new Basic_short(source);
        }

        private static readonly Basic_short _empty = new Basic_short().Frozen();
        public Basic_short Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_short : EntityBase, IBasic_short, IEquatable<Basic_short>, ICopyFrom<Basic_short>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 4;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Int16 field_ScalarRequired;
        private Int16? field_ScalarOptional;
        private ImmutableList<Int16>? field_VectorRequired;
        private ImmutableList<Int16?>? field_VectorOptional;
        private ImmutableDictionary<String, Int16>? field_MapRequired;
        private ImmutableDictionary<String, Int16?>? field_MapOptional;
        private ImmutableDictionary<Int16, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public Int16 ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Int16? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<Int16>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<Int16?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, Int16>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, Int16?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Int16, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_short methods ----------
        Int16 IBasic_short.ScalarRequired => field_ScalarRequired.ToExternal();
        Int16? IBasic_short.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Int16>? IBasic_short.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Int16, Int16>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Int16?>? IBasic_short.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Int16?, Int16?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Int16>? IBasic_short.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Int16, Int16>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Int16?>? IBasic_short.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Int16?, Int16?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Int16, String?>? IBasic_short.MapKey => field_MapKey;

        public Basic_short()
        {
        }

        public Basic_short(Basic_short source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_short source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_short(IBasic_short source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<Int16>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<Int16?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, Int16>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, Int16>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, Int16?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, Int16?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Int16, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_short? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_short left, Basic_short right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_short left, Basic_short right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_short other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_ushort_Factory : IEntityFactory<IBasic_ushort, Basic_ushort>
    {
        private static readonly Basic_ushort_Factory _instance = new Basic_ushort_Factory();
        public static Basic_ushort_Factory Instance => _instance;

        public Basic_ushort? CreateFrom(IBasic_ushort? source)
        {
            if (source is null) return null;
            if (source is Basic_ushort sibling && sibling.IsFrozen()) return sibling;
            return new Basic_ushort(source);
        }

        private static readonly Basic_ushort _empty = new Basic_ushort().Frozen();
        public Basic_ushort Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_ushort : EntityBase, IBasic_ushort, IEquatable<Basic_ushort>, ICopyFrom<Basic_ushort>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 5;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private UInt16 field_ScalarRequired;
        private UInt16? field_ScalarOptional;
        private ImmutableList<UInt16>? field_VectorRequired;
        private ImmutableList<UInt16?>? field_VectorOptional;
        private ImmutableDictionary<String, UInt16>? field_MapRequired;
        private ImmutableDictionary<String, UInt16?>? field_MapOptional;
        private ImmutableDictionary<UInt16, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public UInt16 ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public UInt16? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<UInt16>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<UInt16?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, UInt16>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, UInt16?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<UInt16, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_ushort methods ----------
        UInt16 IBasic_ushort.ScalarRequired => field_ScalarRequired.ToExternal();
        UInt16? IBasic_ushort.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<UInt16>? IBasic_ushort.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<UInt16, UInt16>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<UInt16?>? IBasic_ushort.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<UInt16?, UInt16?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, UInt16>? IBasic_ushort.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, UInt16, UInt16>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, UInt16?>? IBasic_ushort.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, UInt16?, UInt16?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<UInt16, String?>? IBasic_ushort.MapKey => field_MapKey;

        public Basic_ushort()
        {
        }

        public Basic_ushort(Basic_ushort source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_ushort source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_ushort(IBasic_ushort source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<UInt16>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<UInt16?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, UInt16>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, UInt16>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, UInt16?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, UInt16?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<UInt16, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_ushort? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_ushort left, Basic_ushort right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_ushort left, Basic_ushort right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_ushort other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_char_Factory : IEntityFactory<IBasic_char, Basic_char>
    {
        private static readonly Basic_char_Factory _instance = new Basic_char_Factory();
        public static Basic_char_Factory Instance => _instance;

        public Basic_char? CreateFrom(IBasic_char? source)
        {
            if (source is null) return null;
            if (source is Basic_char sibling && sibling.IsFrozen()) return sibling;
            return new Basic_char(source);
        }

        private static readonly Basic_char _empty = new Basic_char().Frozen();
        public Basic_char Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_char : EntityBase, IBasic_char, IEquatable<Basic_char>, ICopyFrom<Basic_char>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 6;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Char field_ScalarRequired;
        private Char? field_ScalarOptional;
        private ImmutableList<Char>? field_VectorRequired;
        private ImmutableList<Char?>? field_VectorOptional;
        private ImmutableDictionary<String, Char>? field_MapRequired;
        private ImmutableDictionary<String, Char?>? field_MapOptional;
        private ImmutableDictionary<Char, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public Char ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Char? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<Char>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<Char?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, Char>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, Char?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Char, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_char methods ----------
        Char IBasic_char.ScalarRequired => field_ScalarRequired.ToExternal();
        Char? IBasic_char.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Char>? IBasic_char.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Char, Char>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Char?>? IBasic_char.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Char?, Char?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Char>? IBasic_char.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Char, Char>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Char?>? IBasic_char.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Char?, Char?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Char, String?>? IBasic_char.MapKey => field_MapKey;

        public Basic_char()
        {
        }

        public Basic_char(Basic_char source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_char source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_char(IBasic_char source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<Char>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<Char?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, Char>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, Char>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, Char?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, Char?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Char, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_char? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_char left, Basic_char right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_char left, Basic_char right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_char other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_int_Factory : IEntityFactory<IBasic_int, Basic_int>
    {
        private static readonly Basic_int_Factory _instance = new Basic_int_Factory();
        public static Basic_int_Factory Instance => _instance;

        public Basic_int? CreateFrom(IBasic_int? source)
        {
            if (source is null) return null;
            if (source is Basic_int sibling && sibling.IsFrozen()) return sibling;
            return new Basic_int(source);
        }

        private static readonly Basic_int _empty = new Basic_int().Frozen();
        public Basic_int Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_int : EntityBase, IBasic_int, IEquatable<Basic_int>, ICopyFrom<Basic_int>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 7;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Int32 field_ScalarRequired;
        private Int32? field_ScalarOptional;
        private ImmutableList<Int32>? field_VectorRequired;
        private ImmutableList<Int32?>? field_VectorOptional;
        private ImmutableDictionary<String, Int32>? field_MapRequired;
        private ImmutableDictionary<String, Int32?>? field_MapOptional;
        private ImmutableDictionary<Int32, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public Int32 ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Int32? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<Int32>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<Int32?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, Int32>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, Int32?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Int32, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_int methods ----------
        Int32 IBasic_int.ScalarRequired => field_ScalarRequired.ToExternal();
        Int32? IBasic_int.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Int32>? IBasic_int.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Int32, Int32>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Int32?>? IBasic_int.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Int32?, Int32?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Int32>? IBasic_int.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Int32, Int32>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Int32?>? IBasic_int.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Int32?, Int32?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Int32, String?>? IBasic_int.MapKey => field_MapKey;

        public Basic_int()
        {
        }

        public Basic_int(Basic_int source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_int source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_int(IBasic_int source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<Int32>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<Int32?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, Int32>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, Int32>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, Int32?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, Int32?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Int32, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_int? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_int left, Basic_int right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_int left, Basic_int right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_int other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_uint_Factory : IEntityFactory<IBasic_uint, Basic_uint>
    {
        private static readonly Basic_uint_Factory _instance = new Basic_uint_Factory();
        public static Basic_uint_Factory Instance => _instance;

        public Basic_uint? CreateFrom(IBasic_uint? source)
        {
            if (source is null) return null;
            if (source is Basic_uint sibling && sibling.IsFrozen()) return sibling;
            return new Basic_uint(source);
        }

        private static readonly Basic_uint _empty = new Basic_uint().Frozen();
        public Basic_uint Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_uint : EntityBase, IBasic_uint, IEquatable<Basic_uint>, ICopyFrom<Basic_uint>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 8;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private UInt32 field_ScalarRequired;
        private UInt32? field_ScalarOptional;
        private ImmutableList<UInt32>? field_VectorRequired;
        private ImmutableList<UInt32?>? field_VectorOptional;
        private ImmutableDictionary<String, UInt32>? field_MapRequired;
        private ImmutableDictionary<String, UInt32?>? field_MapOptional;
        private ImmutableDictionary<UInt32, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public UInt32 ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public UInt32? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<UInt32>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<UInt32?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, UInt32>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, UInt32?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<UInt32, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_uint methods ----------
        UInt32 IBasic_uint.ScalarRequired => field_ScalarRequired.ToExternal();
        UInt32? IBasic_uint.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<UInt32>? IBasic_uint.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<UInt32, UInt32>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<UInt32?>? IBasic_uint.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<UInt32?, UInt32?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, UInt32>? IBasic_uint.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, UInt32, UInt32>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, UInt32?>? IBasic_uint.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, UInt32?, UInt32?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<UInt32, String?>? IBasic_uint.MapKey => field_MapKey;

        public Basic_uint()
        {
        }

        public Basic_uint(Basic_uint source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_uint source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_uint(IBasic_uint source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<UInt32>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<UInt32?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, UInt32>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, UInt32>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, UInt32?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, UInt32?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<UInt32, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_uint? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_uint left, Basic_uint right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_uint left, Basic_uint right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_uint other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_float_Factory : IEntityFactory<IBasic_float, Basic_float>
    {
        private static readonly Basic_float_Factory _instance = new Basic_float_Factory();
        public static Basic_float_Factory Instance => _instance;

        public Basic_float? CreateFrom(IBasic_float? source)
        {
            if (source is null) return null;
            if (source is Basic_float sibling && sibling.IsFrozen()) return sibling;
            return new Basic_float(source);
        }

        private static readonly Basic_float _empty = new Basic_float().Frozen();
        public Basic_float Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_float : EntityBase, IBasic_float, IEquatable<Basic_float>, ICopyFrom<Basic_float>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 9;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Single field_ScalarRequired;
        private Single? field_ScalarOptional;
        private ImmutableList<Single>? field_VectorRequired;
        private ImmutableList<Single?>? field_VectorOptional;
        private ImmutableDictionary<String, Single>? field_MapRequired;
        private ImmutableDictionary<String, Single?>? field_MapOptional;
        private ImmutableDictionary<Single, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public Single ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Single? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<Single>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<Single?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, Single>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, Single?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Single, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_float methods ----------
        Single IBasic_float.ScalarRequired => field_ScalarRequired.ToExternal();
        Single? IBasic_float.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Single>? IBasic_float.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Single, Single>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Single?>? IBasic_float.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Single?, Single?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Single>? IBasic_float.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Single, Single>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Single?>? IBasic_float.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Single?, Single?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Single, String?>? IBasic_float.MapKey => field_MapKey;

        public Basic_float()
        {
        }

        public Basic_float(Basic_float source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_float source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_float(IBasic_float source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<Single>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<Single?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, Single>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, Single>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, Single?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, Single?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Single, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_float? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_float left, Basic_float right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_float left, Basic_float right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_float other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_long_Factory : IEntityFactory<IBasic_long, Basic_long>
    {
        private static readonly Basic_long_Factory _instance = new Basic_long_Factory();
        public static Basic_long_Factory Instance => _instance;

        public Basic_long? CreateFrom(IBasic_long? source)
        {
            if (source is null) return null;
            if (source is Basic_long sibling && sibling.IsFrozen()) return sibling;
            return new Basic_long(source);
        }

        private static readonly Basic_long _empty = new Basic_long().Frozen();
        public Basic_long Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_long : EntityBase, IBasic_long, IEquatable<Basic_long>, ICopyFrom<Basic_long>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 10;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Int64 field_ScalarRequired;
        private Int64? field_ScalarOptional;
        private ImmutableList<Int64>? field_VectorRequired;
        private ImmutableList<Int64?>? field_VectorOptional;
        private ImmutableDictionary<String, Int64>? field_MapRequired;
        private ImmutableDictionary<String, Int64?>? field_MapOptional;
        private ImmutableDictionary<Int64, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public Int64 ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Int64? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<Int64>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<Int64?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, Int64>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, Int64?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Int64, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_long methods ----------
        Int64 IBasic_long.ScalarRequired => field_ScalarRequired.ToExternal();
        Int64? IBasic_long.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Int64>? IBasic_long.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Int64, Int64>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Int64?>? IBasic_long.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Int64?, Int64?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Int64>? IBasic_long.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Int64, Int64>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Int64?>? IBasic_long.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Int64?, Int64?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Int64, String?>? IBasic_long.MapKey => field_MapKey;

        public Basic_long()
        {
        }

        public Basic_long(Basic_long source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_long source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_long(IBasic_long source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<Int64>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<Int64?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, Int64>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, Int64>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, Int64?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, Int64?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Int64, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_long? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_long left, Basic_long right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_long left, Basic_long right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_long other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_ulong_Factory : IEntityFactory<IBasic_ulong, Basic_ulong>
    {
        private static readonly Basic_ulong_Factory _instance = new Basic_ulong_Factory();
        public static Basic_ulong_Factory Instance => _instance;

        public Basic_ulong? CreateFrom(IBasic_ulong? source)
        {
            if (source is null) return null;
            if (source is Basic_ulong sibling && sibling.IsFrozen()) return sibling;
            return new Basic_ulong(source);
        }

        private static readonly Basic_ulong _empty = new Basic_ulong().Frozen();
        public Basic_ulong Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_ulong : EntityBase, IBasic_ulong, IEquatable<Basic_ulong>, ICopyFrom<Basic_ulong>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 11;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private UInt64 field_ScalarRequired;
        private UInt64? field_ScalarOptional;
        private ImmutableList<UInt64>? field_VectorRequired;
        private ImmutableList<UInt64?>? field_VectorOptional;
        private ImmutableDictionary<String, UInt64>? field_MapRequired;
        private ImmutableDictionary<String, UInt64?>? field_MapOptional;
        private ImmutableDictionary<UInt64, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public UInt64 ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public UInt64? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<UInt64>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<UInt64?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, UInt64>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, UInt64?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<UInt64, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_ulong methods ----------
        UInt64 IBasic_ulong.ScalarRequired => field_ScalarRequired.ToExternal();
        UInt64? IBasic_ulong.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<UInt64>? IBasic_ulong.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<UInt64, UInt64>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<UInt64?>? IBasic_ulong.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<UInt64?, UInt64?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, UInt64>? IBasic_ulong.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, UInt64, UInt64>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, UInt64?>? IBasic_ulong.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, UInt64?, UInt64?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<UInt64, String?>? IBasic_ulong.MapKey => field_MapKey;

        public Basic_ulong()
        {
        }

        public Basic_ulong(Basic_ulong source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_ulong source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_ulong(IBasic_ulong source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<UInt64>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<UInt64?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, UInt64>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, UInt64>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, UInt64?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, UInt64?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<UInt64, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_ulong? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_ulong left, Basic_ulong right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_ulong left, Basic_ulong right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_ulong other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_double_Factory : IEntityFactory<IBasic_double, Basic_double>
    {
        private static readonly Basic_double_Factory _instance = new Basic_double_Factory();
        public static Basic_double_Factory Instance => _instance;

        public Basic_double? CreateFrom(IBasic_double? source)
        {
            if (source is null) return null;
            if (source is Basic_double sibling && sibling.IsFrozen()) return sibling;
            return new Basic_double(source);
        }

        private static readonly Basic_double _empty = new Basic_double().Frozen();
        public Basic_double Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_double : EntityBase, IBasic_double, IEquatable<Basic_double>, ICopyFrom<Basic_double>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 12;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Double field_ScalarRequired;
        private Double? field_ScalarOptional;
        private ImmutableList<Double>? field_VectorRequired;
        private ImmutableList<Double?>? field_VectorOptional;
        private ImmutableDictionary<String, Double>? field_MapRequired;
        private ImmutableDictionary<String, Double?>? field_MapOptional;
        private ImmutableDictionary<Double, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public Double ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Double? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<Double>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<Double?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, Double>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, Double?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Double, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_double methods ----------
        Double IBasic_double.ScalarRequired => field_ScalarRequired.ToExternal();
        Double? IBasic_double.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Double>? IBasic_double.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Double, Double>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Double?>? IBasic_double.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Double?, Double?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Double>? IBasic_double.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Double, Double>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Double?>? IBasic_double.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Double?, Double?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Double, String?>? IBasic_double.MapKey => field_MapKey;

        public Basic_double()
        {
        }

        public Basic_double(Basic_double source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_double source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_double(IBasic_double source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<Double>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<Double?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, Double>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, Double>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, Double?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, Double?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Double, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_double? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_double left, Basic_double right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_double left, Basic_double right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_double other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_DateTime_Factory : IEntityFactory<IBasic_DateTime, Basic_DateTime>
    {
        private static readonly Basic_DateTime_Factory _instance = new Basic_DateTime_Factory();
        public static Basic_DateTime_Factory Instance => _instance;

        public Basic_DateTime? CreateFrom(IBasic_DateTime? source)
        {
            if (source is null) return null;
            if (source is Basic_DateTime sibling && sibling.IsFrozen()) return sibling;
            return new Basic_DateTime(source);
        }

        private static readonly Basic_DateTime _empty = new Basic_DateTime().Frozen();
        public Basic_DateTime Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_DateTime : EntityBase, IBasic_DateTime, IEquatable<Basic_DateTime>, ICopyFrom<Basic_DateTime>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 13;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private DateTimeValue field_ScalarRequired;
        private DateTimeValue? field_ScalarOptional;
        private ImmutableList<DateTimeValue>? field_VectorRequired;
        private ImmutableList<DateTimeValue?>? field_VectorOptional;
        private ImmutableDictionary<String, DateTimeValue>? field_MapRequired;
        private ImmutableDictionary<String, DateTimeValue?>? field_MapOptional;
        private ImmutableDictionary<DateTime, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public DateTimeValue ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public DateTimeValue? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<DateTimeValue>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<DateTimeValue?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, DateTimeValue>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, DateTimeValue?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<DateTime, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_DateTime methods ----------
        DateTime IBasic_DateTime.ScalarRequired => field_ScalarRequired.ToExternal();
        DateTime? IBasic_DateTime.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<DateTime>? IBasic_DateTime.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<DateTime, DateTimeValue>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<DateTime?>? IBasic_DateTime.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<DateTime?, DateTimeValue?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, DateTime>? IBasic_DateTime.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, DateTime, DateTimeValue>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, DateTime?>? IBasic_DateTime.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, DateTime?, DateTimeValue?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<DateTime, String?>? IBasic_DateTime.MapKey => field_MapKey;

        public Basic_DateTime()
        {
        }

        public Basic_DateTime(Basic_DateTime source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_DateTime source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_DateTime(IBasic_DateTime source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<DateTimeValue>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<DateTimeValue?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, DateTimeValue>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, DateTimeValue>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, DateTimeValue?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, DateTimeValue?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<DateTime, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_DateTime? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_DateTime left, Basic_DateTime right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_DateTime left, Basic_DateTime right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_DateTime other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_TimeSpan_Factory : IEntityFactory<IBasic_TimeSpan, Basic_TimeSpan>
    {
        private static readonly Basic_TimeSpan_Factory _instance = new Basic_TimeSpan_Factory();
        public static Basic_TimeSpan_Factory Instance => _instance;

        public Basic_TimeSpan? CreateFrom(IBasic_TimeSpan? source)
        {
            if (source is null) return null;
            if (source is Basic_TimeSpan sibling && sibling.IsFrozen()) return sibling;
            return new Basic_TimeSpan(source);
        }

        private static readonly Basic_TimeSpan _empty = new Basic_TimeSpan().Frozen();
        public Basic_TimeSpan Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_TimeSpan : EntityBase, IBasic_TimeSpan, IEquatable<Basic_TimeSpan>, ICopyFrom<Basic_TimeSpan>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 14;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private TimeSpan field_ScalarRequired;
        private TimeSpan? field_ScalarOptional;
        private ImmutableList<TimeSpan>? field_VectorRequired;
        private ImmutableList<TimeSpan?>? field_VectorOptional;
        private ImmutableDictionary<String, TimeSpan>? field_MapRequired;
        private ImmutableDictionary<String, TimeSpan?>? field_MapOptional;
        private ImmutableDictionary<TimeSpan, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public TimeSpan ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public TimeSpan? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<TimeSpan>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<TimeSpan?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, TimeSpan>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, TimeSpan?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<TimeSpan, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_TimeSpan methods ----------
        TimeSpan IBasic_TimeSpan.ScalarRequired => field_ScalarRequired.ToExternal();
        TimeSpan? IBasic_TimeSpan.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<TimeSpan>? IBasic_TimeSpan.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<TimeSpan, TimeSpan>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<TimeSpan?>? IBasic_TimeSpan.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<TimeSpan?, TimeSpan?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, TimeSpan>? IBasic_TimeSpan.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, TimeSpan, TimeSpan>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, TimeSpan?>? IBasic_TimeSpan.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, TimeSpan?, TimeSpan?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<TimeSpan, String?>? IBasic_TimeSpan.MapKey => field_MapKey;

        public Basic_TimeSpan()
        {
        }

        public Basic_TimeSpan(Basic_TimeSpan source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_TimeSpan source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_TimeSpan(IBasic_TimeSpan source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<TimeSpan>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<TimeSpan?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, TimeSpan>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, TimeSpan>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, TimeSpan?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, TimeSpan?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<TimeSpan, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_TimeSpan? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_TimeSpan left, Basic_TimeSpan right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_TimeSpan left, Basic_TimeSpan right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_TimeSpan other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_decimal_Factory : IEntityFactory<IBasic_decimal, Basic_decimal>
    {
        private static readonly Basic_decimal_Factory _instance = new Basic_decimal_Factory();
        public static Basic_decimal_Factory Instance => _instance;

        public Basic_decimal? CreateFrom(IBasic_decimal? source)
        {
            if (source is null) return null;
            if (source is Basic_decimal sibling && sibling.IsFrozen()) return sibling;
            return new Basic_decimal(source);
        }

        private static readonly Basic_decimal _empty = new Basic_decimal().Frozen();
        public Basic_decimal Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_decimal : EntityBase, IBasic_decimal, IEquatable<Basic_decimal>, ICopyFrom<Basic_decimal>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 17;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private DecimalValue field_ScalarRequired;
        private DecimalValue? field_ScalarOptional;
        private ImmutableList<DecimalValue>? field_VectorRequired;
        private ImmutableList<DecimalValue?>? field_VectorOptional;
        private ImmutableDictionary<String, DecimalValue>? field_MapRequired;
        private ImmutableDictionary<String, DecimalValue?>? field_MapOptional;
        private ImmutableDictionary<Decimal, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public DecimalValue ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public DecimalValue? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<DecimalValue>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<DecimalValue?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, DecimalValue>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, DecimalValue?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Decimal, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_decimal methods ----------
        Decimal IBasic_decimal.ScalarRequired => field_ScalarRequired.ToExternal();
        Decimal? IBasic_decimal.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Decimal>? IBasic_decimal.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Decimal, DecimalValue>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Decimal?>? IBasic_decimal.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Decimal?, DecimalValue?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Decimal>? IBasic_decimal.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Decimal, DecimalValue>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Decimal?>? IBasic_decimal.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Decimal?, DecimalValue?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Decimal, String?>? IBasic_decimal.MapKey => field_MapKey;

        public Basic_decimal()
        {
        }

        public Basic_decimal(Basic_decimal source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_decimal source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_decimal(IBasic_decimal source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<DecimalValue>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<DecimalValue?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, DecimalValue>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, DecimalValue>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, DecimalValue?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, DecimalValue?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Decimal, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_decimal? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_decimal left, Basic_decimal right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_decimal left, Basic_decimal right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_decimal other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_DateTimeOffset_Factory : IEntityFactory<IBasic_DateTimeOffset, Basic_DateTimeOffset>
    {
        private static readonly Basic_DateTimeOffset_Factory _instance = new Basic_DateTimeOffset_Factory();
        public static Basic_DateTimeOffset_Factory Instance => _instance;

        public Basic_DateTimeOffset? CreateFrom(IBasic_DateTimeOffset? source)
        {
            if (source is null) return null;
            if (source is Basic_DateTimeOffset sibling && sibling.IsFrozen()) return sibling;
            return new Basic_DateTimeOffset(source);
        }

        private static readonly Basic_DateTimeOffset _empty = new Basic_DateTimeOffset().Frozen();
        public Basic_DateTimeOffset Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_DateTimeOffset : EntityBase, IBasic_DateTimeOffset, IEquatable<Basic_DateTimeOffset>, ICopyFrom<Basic_DateTimeOffset>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 18;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private DateTimeOffsetValue field_ScalarRequired;
        private DateTimeOffsetValue? field_ScalarOptional;
        private ImmutableList<DateTimeOffsetValue>? field_VectorRequired;
        private ImmutableList<DateTimeOffsetValue?>? field_VectorOptional;
        private ImmutableDictionary<String, DateTimeOffsetValue>? field_MapRequired;
        private ImmutableDictionary<String, DateTimeOffsetValue?>? field_MapOptional;
        private ImmutableDictionary<DateTimeOffset, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public DateTimeOffsetValue ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public DateTimeOffsetValue? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<DateTimeOffsetValue>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<DateTimeOffsetValue?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, DateTimeOffsetValue>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, DateTimeOffsetValue?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<DateTimeOffset, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_DateTimeOffset methods ----------
        DateTimeOffset IBasic_DateTimeOffset.ScalarRequired => field_ScalarRequired.ToExternal();
        DateTimeOffset? IBasic_DateTimeOffset.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<DateTimeOffset>? IBasic_DateTimeOffset.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<DateTimeOffset, DateTimeOffsetValue>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<DateTimeOffset?>? IBasic_DateTimeOffset.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<DateTimeOffset?, DateTimeOffsetValue?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, DateTimeOffset>? IBasic_DateTimeOffset.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, DateTimeOffset, DateTimeOffsetValue>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, DateTimeOffset?>? IBasic_DateTimeOffset.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, DateTimeOffset?, DateTimeOffsetValue?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<DateTimeOffset, String?>? IBasic_DateTimeOffset.MapKey => field_MapKey;

        public Basic_DateTimeOffset()
        {
        }

        public Basic_DateTimeOffset(Basic_DateTimeOffset source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_DateTimeOffset source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_DateTimeOffset(IBasic_DateTimeOffset source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<DateTimeOffsetValue>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<DateTimeOffsetValue?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, DateTimeOffsetValue>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, DateTimeOffsetValue>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, DateTimeOffsetValue?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, DateTimeOffsetValue?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<DateTimeOffset, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_DateTimeOffset? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_DateTimeOffset left, Basic_DateTimeOffset right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_DateTimeOffset left, Basic_DateTimeOffset right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_DateTimeOffset other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_Guid_Factory : IEntityFactory<IBasic_Guid, Basic_Guid>
    {
        private static readonly Basic_Guid_Factory _instance = new Basic_Guid_Factory();
        public static Basic_Guid_Factory Instance => _instance;

        public Basic_Guid? CreateFrom(IBasic_Guid? source)
        {
            if (source is null) return null;
            if (source is Basic_Guid sibling && sibling.IsFrozen()) return sibling;
            return new Basic_Guid(source);
        }

        private static readonly Basic_Guid _empty = new Basic_Guid().Frozen();
        public Basic_Guid Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_Guid : EntityBase, IBasic_Guid, IEquatable<Basic_Guid>, ICopyFrom<Basic_Guid>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 19;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private GuidValue field_ScalarRequired;
        private GuidValue? field_ScalarOptional;
        private ImmutableList<GuidValue>? field_VectorRequired;
        private ImmutableList<GuidValue?>? field_VectorOptional;
        private ImmutableDictionary<String, GuidValue>? field_MapRequired;
        private ImmutableDictionary<String, GuidValue?>? field_MapOptional;
        private ImmutableDictionary<Guid, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public GuidValue ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public GuidValue? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<GuidValue>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<GuidValue?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, GuidValue>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, GuidValue?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Guid, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_Guid methods ----------
        Guid IBasic_Guid.ScalarRequired => field_ScalarRequired.ToExternal();
        Guid? IBasic_Guid.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Guid>? IBasic_Guid.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Guid, GuidValue>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Guid?>? IBasic_Guid.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Guid?, GuidValue?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Guid>? IBasic_Guid.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Guid, GuidValue>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Guid?>? IBasic_Guid.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Guid?, GuidValue?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Guid, String?>? IBasic_Guid.MapKey => field_MapKey;

        public Basic_Guid()
        {
        }

        public Basic_Guid(Basic_Guid source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_Guid source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_Guid(IBasic_Guid source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<GuidValue>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<GuidValue?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, GuidValue>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, GuidValue>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, GuidValue?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, GuidValue?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Guid, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_Guid? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_Guid left, Basic_Guid right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_Guid left, Basic_Guid right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_Guid other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_DayOfWeek_Factory : IEntityFactory<IBasic_DayOfWeek, Basic_DayOfWeek>
    {
        private static readonly Basic_DayOfWeek_Factory _instance = new Basic_DayOfWeek_Factory();
        public static Basic_DayOfWeek_Factory Instance => _instance;

        public Basic_DayOfWeek? CreateFrom(IBasic_DayOfWeek? source)
        {
            if (source is null) return null;
            if (source is Basic_DayOfWeek sibling && sibling.IsFrozen()) return sibling;
            return new Basic_DayOfWeek(source);
        }

        private static readonly Basic_DayOfWeek _empty = new Basic_DayOfWeek().Frozen();
        public Basic_DayOfWeek Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_DayOfWeek : EntityBase, IBasic_DayOfWeek, IEquatable<Basic_DayOfWeek>, ICopyFrom<Basic_DayOfWeek>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 20;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private System.DayOfWeek field_ScalarRequired;
        private System.DayOfWeek? field_ScalarOptional;
        private ImmutableList<System.DayOfWeek>? field_VectorRequired;
        private ImmutableList<System.DayOfWeek?>? field_VectorOptional;
        private ImmutableDictionary<String, System.DayOfWeek>? field_MapRequired;
        private ImmutableDictionary<String, System.DayOfWeek?>? field_MapOptional;
        private ImmutableDictionary<System.DayOfWeek, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public System.DayOfWeek ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public System.DayOfWeek? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<System.DayOfWeek>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<System.DayOfWeek?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, System.DayOfWeek>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, System.DayOfWeek?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<System.DayOfWeek, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_DayOfWeek methods ----------
        System.DayOfWeek IBasic_DayOfWeek.ScalarRequired => field_ScalarRequired.ToExternal();
        System.DayOfWeek? IBasic_DayOfWeek.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<System.DayOfWeek>? IBasic_DayOfWeek.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<System.DayOfWeek, System.DayOfWeek>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<System.DayOfWeek?>? IBasic_DayOfWeek.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<System.DayOfWeek?, System.DayOfWeek?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, System.DayOfWeek>? IBasic_DayOfWeek.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, System.DayOfWeek, System.DayOfWeek>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, System.DayOfWeek?>? IBasic_DayOfWeek.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, System.DayOfWeek?, System.DayOfWeek?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<System.DayOfWeek, String?>? IBasic_DayOfWeek.MapKey => field_MapKey;

        public Basic_DayOfWeek()
        {
        }

        public Basic_DayOfWeek(Basic_DayOfWeek source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_DayOfWeek source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_DayOfWeek(IBasic_DayOfWeek source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<System.DayOfWeek>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<System.DayOfWeek?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, System.DayOfWeek>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, System.DayOfWeek>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, System.DayOfWeek?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, System.DayOfWeek?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<System.DayOfWeek, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_DayOfWeek? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_DayOfWeek left, Basic_DayOfWeek right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_DayOfWeek left, Basic_DayOfWeek right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_DayOfWeek other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_MyCustomEnum_Factory : IEntityFactory<IBasic_MyCustomEnum, Basic_MyCustomEnum>
    {
        private static readonly Basic_MyCustomEnum_Factory _instance = new Basic_MyCustomEnum_Factory();
        public static Basic_MyCustomEnum_Factory Instance => _instance;

        public Basic_MyCustomEnum? CreateFrom(IBasic_MyCustomEnum? source)
        {
            if (source is null) return null;
            if (source is Basic_MyCustomEnum sibling && sibling.IsFrozen()) return sibling;
            return new Basic_MyCustomEnum(source);
        }

        private static readonly Basic_MyCustomEnum _empty = new Basic_MyCustomEnum().Frozen();
        public Basic_MyCustomEnum Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_MyCustomEnum : EntityBase, IBasic_MyCustomEnum, IEquatable<Basic_MyCustomEnum>, ICopyFrom<Basic_MyCustomEnum>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 21;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private MyCustomEnum field_ScalarRequired;
        private MyCustomEnum? field_ScalarOptional;
        private ImmutableList<MyCustomEnum>? field_VectorRequired;
        private ImmutableList<MyCustomEnum?>? field_VectorOptional;
        private ImmutableDictionary<String, MyCustomEnum>? field_MapRequired;
        private ImmutableDictionary<String, MyCustomEnum?>? field_MapOptional;
        private ImmutableDictionary<MyCustomEnum, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public MyCustomEnum ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public MyCustomEnum? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<MyCustomEnum>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<MyCustomEnum?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, MyCustomEnum>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, MyCustomEnum?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<MyCustomEnum, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_MyCustomEnum methods ----------
        MyCustomEnum IBasic_MyCustomEnum.ScalarRequired => field_ScalarRequired.ToExternal();
        MyCustomEnum? IBasic_MyCustomEnum.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<MyCustomEnum>? IBasic_MyCustomEnum.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<MyCustomEnum, MyCustomEnum>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<MyCustomEnum?>? IBasic_MyCustomEnum.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<MyCustomEnum?, MyCustomEnum?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, MyCustomEnum>? IBasic_MyCustomEnum.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, MyCustomEnum, MyCustomEnum>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, MyCustomEnum?>? IBasic_MyCustomEnum.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, MyCustomEnum?, MyCustomEnum?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<MyCustomEnum, String?>? IBasic_MyCustomEnum.MapKey => field_MapKey;

        public Basic_MyCustomEnum()
        {
        }

        public Basic_MyCustomEnum(Basic_MyCustomEnum source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_MyCustomEnum source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_MyCustomEnum(IBasic_MyCustomEnum source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<MyCustomEnum>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<MyCustomEnum?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, MyCustomEnum>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, MyCustomEnum>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, MyCustomEnum?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, MyCustomEnum?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<MyCustomEnum, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_MyCustomEnum? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_MyCustomEnum left, Basic_MyCustomEnum right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_MyCustomEnum left, Basic_MyCustomEnum right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_MyCustomEnum other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_Quantity_Factory : IEntityFactory<IBasic_Quantity, Basic_Quantity>
    {
        private static readonly Basic_Quantity_Factory _instance = new Basic_Quantity_Factory();
        public static Basic_Quantity_Factory Instance => _instance;

        public Basic_Quantity? CreateFrom(IBasic_Quantity? source)
        {
            if (source is null) return null;
            if (source is Basic_Quantity sibling && sibling.IsFrozen()) return sibling;
            return new Basic_Quantity(source);
        }

        private static readonly Basic_Quantity _empty = new Basic_Quantity().Frozen();
        public Basic_Quantity Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_Quantity : EntityBase, IBasic_Quantity, IEquatable<Basic_Quantity>, ICopyFrom<Basic_Quantity>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 22;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private QuantityValue field_ScalarRequired;
        private QuantityValue? field_ScalarOptional;
        private ImmutableList<QuantityValue>? field_VectorRequired;
        private ImmutableList<QuantityValue?>? field_VectorOptional;
        private ImmutableDictionary<String, QuantityValue>? field_MapRequired;
        private ImmutableDictionary<String, QuantityValue?>? field_MapOptional;

        // ---------- accessors ----------
        [Key(1)]
        public QuantityValue ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public QuantityValue? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<QuantityValue>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<QuantityValue?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, QuantityValue>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, QuantityValue?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_Quantity methods ----------
        LabApps.Units.Quantity IBasic_Quantity.ScalarRequired => field_ScalarRequired.ToExternal();
        LabApps.Units.Quantity? IBasic_Quantity.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<LabApps.Units.Quantity>? IBasic_Quantity.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<LabApps.Units.Quantity, QuantityValue>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<LabApps.Units.Quantity?>? IBasic_Quantity.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<LabApps.Units.Quantity?, QuantityValue?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, LabApps.Units.Quantity>? IBasic_Quantity.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, LabApps.Units.Quantity, QuantityValue>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, LabApps.Units.Quantity?>? IBasic_Quantity.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, LabApps.Units.Quantity?, QuantityValue?>(field_MapOptional, (x) => x.ToExternal());

        public Basic_Quantity()
        {
        }

        public Basic_Quantity(Basic_Quantity source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
        }

        public void CopyFrom(Basic_Quantity source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
        }

        public Basic_Quantity(IBasic_Quantity source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<QuantityValue>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<QuantityValue?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, QuantityValue>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, QuantityValue>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, QuantityValue?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, QuantityValue?>(kvp.Key, kvp.Value.ToInternal())));
        }

        public bool Equals(Basic_Quantity? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_Quantity left, Basic_Quantity right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_Quantity left, Basic_Quantity right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_Quantity other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_string_Factory : IEntityFactory<IBasic_string, Basic_string>
    {
        private static readonly Basic_string_Factory _instance = new Basic_string_Factory();
        public static Basic_string_Factory Instance => _instance;

        public Basic_string? CreateFrom(IBasic_string? source)
        {
            if (source is null) return null;
            if (source is Basic_string sibling && sibling.IsFrozen()) return sibling;
            return new Basic_string(source);
        }

        private static readonly Basic_string _empty = new Basic_string().Frozen();
        public Basic_string Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_string : EntityBase, IBasic_string, IEquatable<Basic_string>, ICopyFrom<Basic_string>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 30;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private String? field_Scalar;
        private ImmutableList<String?>? field_Vector;
        private ImmutableDictionary<String, String?>? field_MapValue;

        // ---------- accessors ----------
        [Key(1)]
        public String? Scalar
        {
            get => field_Scalar;
            set => field_Scalar = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public ImmutableList<String?>? Vector
        {
            get => field_Vector;
            set => field_Vector = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableDictionary<String, String?>? MapValue
        {
            get => field_MapValue;
            set => field_MapValue = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_string methods ----------
        String? IBasic_string.Scalar => field_Scalar;
        IReadOnlyList<String?>? IBasic_string.Vector => field_Vector;
        IReadOnlyDictionary<String, String?>? IBasic_string.MapValue => field_MapValue;

        public Basic_string()
        {
        }

        public Basic_string(Basic_string source) : base(source)
        {
            field_Scalar = source.field_Scalar;
            field_Vector = source.field_Vector;
            field_MapValue = source.field_MapValue;
        }

        public void CopyFrom(Basic_string source)
        {
            base.CopyFrom(source);
            field_Scalar = source.field_Scalar;
            field_Vector = source.field_Vector;
            field_MapValue = source.field_MapValue;
        }

        public Basic_string(IBasic_string source) : base(source)
        {
            field_Scalar = source.Scalar;
            field_Vector = source.Vector is null
                ? null
                : ImmutableList<String?>.Empty.AddRange(source.Vector);
            field_MapValue = source.MapValue is null
                ? null
                : ImmutableDictionary<String, String?>.Empty.AddRange(source.MapValue);
        }

        public bool Equals(Basic_string? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Scalar.ValueEquals(other.field_Scalar)) return false;
            if (!field_Vector.ArrayEquals(other.field_Vector)) return false;
            if (!field_MapValue.IndexEquals(other.field_MapValue)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_string left, Basic_string right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_string left, Basic_string right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_string other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Scalar.CalcHashUnary());
            hc.Add(field_Vector.CalcHashArray());
            hc.Add(field_MapValue.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_Octets_Factory : IEntityFactory<IBasic_Octets, Basic_Octets>
    {
        private static readonly Basic_Octets_Factory _instance = new Basic_Octets_Factory();
        public static Basic_Octets_Factory Instance => _instance;

        public Basic_Octets? CreateFrom(IBasic_Octets? source)
        {
            if (source is null) return null;
            if (source is Basic_Octets sibling && sibling.IsFrozen()) return sibling;
            return new Basic_Octets(source);
        }

        private static readonly Basic_Octets _empty = new Basic_Octets().Frozen();
        public Basic_Octets Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_Octets : EntityBase, IBasic_Octets, IEquatable<Basic_Octets>, ICopyFrom<Basic_Octets>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 31;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private BinaryValue? field_Scalar;
        private ImmutableList<BinaryValue?>? field_Vector;
        private ImmutableDictionary<String, BinaryValue?>? field_MapValue;
        private ImmutableDictionary<Octets, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public BinaryValue? Scalar
        {
            get => field_Scalar;
            set => field_Scalar = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public ImmutableList<BinaryValue?>? Vector
        {
            get => field_Vector;
            set => field_Vector = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableDictionary<String, BinaryValue?>? MapValue
        {
            get => field_MapValue;
            set => field_MapValue = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableDictionary<Octets, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_Octets methods ----------
        Octets? IBasic_Octets.Scalar => field_Scalar;
        IReadOnlyList<Octets?>? IBasic_Octets.Vector => field_Vector is null
            ? null
            : new ListFacade<Octets, BinaryValue>(field_Vector, x => (Octets?)x);
        IReadOnlyDictionary<String, Octets?>? IBasic_Octets.MapValue => field_MapValue is null
            ? null
            : new DictionaryFacade<String, Octets?, BinaryValue?>(field_MapValue, x => (Octets?)x);
        IReadOnlyDictionary<Octets, String?>? IBasic_Octets.MapKey => field_MapKey;

        public Basic_Octets()
        {
        }

        public Basic_Octets(Basic_Octets source) : base(source)
        {
            field_Scalar = source.field_Scalar;
            field_Vector = source.field_Vector;
            field_MapValue = source.field_MapValue;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_Octets source)
        {
            base.CopyFrom(source);
            field_Scalar = source.field_Scalar;
            field_Vector = source.field_Vector;
            field_MapValue = source.field_MapValue;
            field_MapKey = source.field_MapKey;
        }

        public Basic_Octets(IBasic_Octets source) : base(source)
        {
            field_Scalar = source.Scalar;
            field_Vector = source.Vector is null
                ? null
                : ImmutableList<BinaryValue?>.Empty.AddRange(source.Vector.Select(x => (BinaryValue?)x));
            field_MapValue = source.MapValue is null
                ? null
                : ImmutableDictionary<String, BinaryValue?>.Empty.AddRange(
                    source.MapValue.Select(kvp => new KeyValuePair<String, BinaryValue?>(kvp.Key, kvp.Value)));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Octets, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_Octets? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Scalar.ValueEquals(other.field_Scalar)) return false;
            if (!field_Vector.ArrayEquals(other.field_Vector)) return false;
            if (!field_MapValue.IndexEquals(other.field_MapValue)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_Octets left, Basic_Octets right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_Octets left, Basic_Octets right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_Octets other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Scalar.CalcHashUnary());
            hc.Add(field_Vector.CalcHashArray());
            hc.Add(field_MapValue.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_Half_Factory : IEntityFactory<IBasic_Half, Basic_Half>
    {
        private static readonly Basic_Half_Factory _instance = new Basic_Half_Factory();
        public static Basic_Half_Factory Instance => _instance;

        public Basic_Half? CreateFrom(IBasic_Half? source)
        {
            if (source is null) return null;
            if (source is Basic_Half sibling && sibling.IsFrozen()) return sibling;
            return new Basic_Half(source);
        }

        private static readonly Basic_Half _empty = new Basic_Half().Frozen();
        public Basic_Half Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_Half : EntityBase, IBasic_Half, IEquatable<Basic_Half>, ICopyFrom<Basic_Half>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 32;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Half field_ScalarRequired;
        private Half? field_ScalarOptional;
        private ImmutableList<Half>? field_VectorRequired;
        private ImmutableList<Half?>? field_VectorOptional;
        private ImmutableDictionary<String, Half>? field_MapRequired;
        private ImmutableDictionary<String, Half?>? field_MapOptional;
        private ImmutableDictionary<Half, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public Half ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Half? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<Half>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<Half?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, Half>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, Half?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Half, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_Half methods ----------
        Half IBasic_Half.ScalarRequired => field_ScalarRequired.ToExternal();
        Half? IBasic_Half.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Half>? IBasic_Half.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Half, Half>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Half?>? IBasic_Half.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Half?, Half?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Half>? IBasic_Half.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Half, Half>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Half?>? IBasic_Half.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Half?, Half?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Half, String?>? IBasic_Half.MapKey => field_MapKey;

        public Basic_Half()
        {
        }

        public Basic_Half(Basic_Half source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_Half source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_Half(IBasic_Half source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<Half>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<Half?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, Half>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, Half>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, Half?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, Half?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Half, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_Half? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_Half left, Basic_Half right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_Half left, Basic_Half right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_Half other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_DateOnly_Factory : IEntityFactory<IBasic_DateOnly, Basic_DateOnly>
    {
        private static readonly Basic_DateOnly_Factory _instance = new Basic_DateOnly_Factory();
        public static Basic_DateOnly_Factory Instance => _instance;

        public Basic_DateOnly? CreateFrom(IBasic_DateOnly? source)
        {
            if (source is null) return null;
            if (source is Basic_DateOnly sibling && sibling.IsFrozen()) return sibling;
            return new Basic_DateOnly(source);
        }

        private static readonly Basic_DateOnly _empty = new Basic_DateOnly().Frozen();
        public Basic_DateOnly Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_DateOnly : EntityBase, IBasic_DateOnly, IEquatable<Basic_DateOnly>, ICopyFrom<Basic_DateOnly>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 33;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private DateOnly field_ScalarRequired;
        private DateOnly? field_ScalarOptional;
        private ImmutableList<DateOnly>? field_VectorRequired;
        private ImmutableList<DateOnly?>? field_VectorOptional;
        private ImmutableDictionary<String, DateOnly>? field_MapRequired;
        private ImmutableDictionary<String, DateOnly?>? field_MapOptional;
        private ImmutableDictionary<DateOnly, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public DateOnly ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public DateOnly? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<DateOnly>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<DateOnly?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, DateOnly>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, DateOnly?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<DateOnly, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_DateOnly methods ----------
        DateOnly IBasic_DateOnly.ScalarRequired => field_ScalarRequired.ToExternal();
        DateOnly? IBasic_DateOnly.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<DateOnly>? IBasic_DateOnly.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<DateOnly, DateOnly>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<DateOnly?>? IBasic_DateOnly.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<DateOnly?, DateOnly?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, DateOnly>? IBasic_DateOnly.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, DateOnly, DateOnly>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, DateOnly?>? IBasic_DateOnly.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, DateOnly?, DateOnly?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<DateOnly, String?>? IBasic_DateOnly.MapKey => field_MapKey;

        public Basic_DateOnly()
        {
        }

        public Basic_DateOnly(Basic_DateOnly source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_DateOnly source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_DateOnly(IBasic_DateOnly source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<DateOnly>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<DateOnly?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, DateOnly>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, DateOnly>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, DateOnly?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, DateOnly?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<DateOnly, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_DateOnly? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_DateOnly left, Basic_DateOnly right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_DateOnly left, Basic_DateOnly right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_DateOnly other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_TimeOnly_Factory : IEntityFactory<IBasic_TimeOnly, Basic_TimeOnly>
    {
        private static readonly Basic_TimeOnly_Factory _instance = new Basic_TimeOnly_Factory();
        public static Basic_TimeOnly_Factory Instance => _instance;

        public Basic_TimeOnly? CreateFrom(IBasic_TimeOnly? source)
        {
            if (source is null) return null;
            if (source is Basic_TimeOnly sibling && sibling.IsFrozen()) return sibling;
            return new Basic_TimeOnly(source);
        }

        private static readonly Basic_TimeOnly _empty = new Basic_TimeOnly().Frozen();
        public Basic_TimeOnly Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_TimeOnly : EntityBase, IBasic_TimeOnly, IEquatable<Basic_TimeOnly>, ICopyFrom<Basic_TimeOnly>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 34;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private TimeOnly field_ScalarRequired;
        private TimeOnly? field_ScalarOptional;
        private ImmutableList<TimeOnly>? field_VectorRequired;
        private ImmutableList<TimeOnly?>? field_VectorOptional;
        private ImmutableDictionary<String, TimeOnly>? field_MapRequired;
        private ImmutableDictionary<String, TimeOnly?>? field_MapOptional;
        private ImmutableDictionary<TimeOnly, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public TimeOnly ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public TimeOnly? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<TimeOnly>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<TimeOnly?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, TimeOnly>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, TimeOnly?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<TimeOnly, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_TimeOnly methods ----------
        TimeOnly IBasic_TimeOnly.ScalarRequired => field_ScalarRequired.ToExternal();
        TimeOnly? IBasic_TimeOnly.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<TimeOnly>? IBasic_TimeOnly.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<TimeOnly, TimeOnly>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<TimeOnly?>? IBasic_TimeOnly.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<TimeOnly?, TimeOnly?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, TimeOnly>? IBasic_TimeOnly.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, TimeOnly, TimeOnly>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, TimeOnly?>? IBasic_TimeOnly.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, TimeOnly?, TimeOnly?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<TimeOnly, String?>? IBasic_TimeOnly.MapKey => field_MapKey;

        public Basic_TimeOnly()
        {
        }

        public Basic_TimeOnly(Basic_TimeOnly source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_TimeOnly source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public Basic_TimeOnly(IBasic_TimeOnly source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<TimeOnly>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<TimeOnly?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, TimeOnly>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, TimeOnly>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, TimeOnly?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, TimeOnly?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<TimeOnly, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_TimeOnly? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_TimeOnly left, Basic_TimeOnly right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_TimeOnly left, Basic_TimeOnly right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_TimeOnly other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_Complex_Factory : IEntityFactory<IBasic_Complex, Basic_Complex>
    {
        private static readonly Basic_Complex_Factory _instance = new Basic_Complex_Factory();
        public static Basic_Complex_Factory Instance => _instance;

        public Basic_Complex? CreateFrom(IBasic_Complex? source)
        {
            if (source is null) return null;
            if (source is Basic_Complex sibling && sibling.IsFrozen()) return sibling;
            return new Basic_Complex(source);
        }

        private static readonly Basic_Complex _empty = new Basic_Complex().Frozen();
        public Basic_Complex Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_Complex : EntityBase, IBasic_Complex, IEquatable<Basic_Complex>, ICopyFrom<Basic_Complex>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 35;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Complex field_ScalarRequired;
        private Complex? field_ScalarOptional;
        private ImmutableList<Complex>? field_VectorRequired;
        private ImmutableList<Complex?>? field_VectorOptional;
        private ImmutableDictionary<String, Complex>? field_MapRequired;
        private ImmutableDictionary<String, Complex?>? field_MapOptional;

        // ---------- accessors ----------
        [Key(1)]
        public Complex ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Complex? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<Complex>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<Complex?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, Complex>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, Complex?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_Complex methods ----------
        Complex IBasic_Complex.ScalarRequired => field_ScalarRequired.ToExternal();
        Complex? IBasic_Complex.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Complex>? IBasic_Complex.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Complex, Complex>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Complex?>? IBasic_Complex.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Complex?, Complex?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Complex>? IBasic_Complex.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Complex, Complex>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Complex?>? IBasic_Complex.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Complex?, Complex?>(field_MapOptional, (x) => x.ToExternal());

        public Basic_Complex()
        {
        }

        public Basic_Complex(Basic_Complex source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
        }

        public void CopyFrom(Basic_Complex source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
        }

        public Basic_Complex(IBasic_Complex source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<Complex>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<Complex?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, Complex>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, Complex>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, Complex?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, Complex?>(kvp.Key, kvp.Value.ToInternal())));
        }

        public bool Equals(Basic_Complex? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_ScalarRequired.ValueEquals(other.field_ScalarRequired)) return false;
            if (!field_ScalarOptional.ValueEquals(other.field_ScalarOptional)) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_Complex left, Basic_Complex right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_Complex left, Basic_Complex right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_Complex other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public sealed class Basic_Version_Factory : IEntityFactory<IBasic_Version, Basic_Version>
    {
        private static readonly Basic_Version_Factory _instance = new Basic_Version_Factory();
        public static Basic_Version_Factory Instance => _instance;

        public Basic_Version? CreateFrom(IBasic_Version? source)
        {
            if (source is null) return null;
            if (source is Basic_Version sibling && sibling.IsFrozen()) return sibling;
            return new Basic_Version(source);
        }

        private static readonly Basic_Version _empty = new Basic_Version().Frozen();
        public Basic_Version Empty => _empty;
    }
    [MessagePackObject]
    public partial class Basic_Version : EntityBase, IBasic_Version, IEquatable<Basic_Version>, ICopyFrom<Basic_Version>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 36;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Version? field_Scalar;
        private ImmutableList<Version?>? field_Vector;
        private ImmutableDictionary<String, Version?>? field_MapValue;

        // ---------- accessors ----------
        [Key(1)]
        public Version? Scalar
        {
            get => field_Scalar;
            set => field_Scalar = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public ImmutableList<Version?>? Vector
        {
            get => field_Vector;
            set => field_Vector = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableDictionary<String, Version?>? MapValue
        {
            get => field_MapValue;
            set => field_MapValue = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_Version methods ----------
        Version? IBasic_Version.Scalar => field_Scalar.ToExternal();
        IReadOnlyList<Version?>? IBasic_Version.Vector
            => field_Vector is null ? null
            : new ListFacade<Version?, Version?>(field_Vector, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Version?>? IBasic_Version.MapValue
            => field_MapValue is null ? null
            : new DictionaryFacade<String, Version?, Version?>(field_MapValue, (x) => x.ToExternal());

        public Basic_Version()
        {
        }

        public Basic_Version(Basic_Version source) : base(source)
        {
            field_Scalar = source.field_Scalar;
            field_Vector = source.field_Vector;
            field_MapValue = source.field_MapValue;
        }

        public void CopyFrom(Basic_Version source)
        {
            base.CopyFrom(source);
            field_Scalar = source.field_Scalar;
            field_Vector = source.field_Vector;
            field_MapValue = source.field_MapValue;
        }

        public Basic_Version(IBasic_Version source) : base(source)
        {
            field_Scalar = source.Scalar.ToInternal();
            field_Vector = source.Vector is null
                ? null
                : ImmutableList<Version?>.Empty.AddRange(source.Vector.Select(x => x.ToInternal()));
            field_MapValue = source.MapValue is null
                ? null
                : ImmutableDictionary<String, Version?>.Empty.AddRange(source.MapValue.Select(
                    kvp => new KeyValuePair<String, Version?>(kvp.Key, kvp.Value.ToInternal())));
        }

        public bool Equals(Basic_Version? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Scalar.ValueEquals(other.field_Scalar)) return false;
            if (!field_Vector.ArrayEquals(other.field_Vector)) return false;
            if (!field_MapValue.IndexEquals(other.field_MapValue)) return false;
            return base.Equals(other);
        }

        public static bool operator ==(Basic_Version left, Basic_Version right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        public static bool operator !=(Basic_Version left, Basic_Version right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        public override bool Equals(object? obj)
        {
            return obj is Basic_Version other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Scalar.CalcHashUnary());
            hc.Add(field_Vector.CalcHashArray());
            hc.Add(field_MapValue.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }


}

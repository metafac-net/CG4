#region Notices
// <auto-generated>
// Warning: This file was automatically generated. Changes to this file may
// cause incorrect behavior and will be lost when this file is regenerated.
// </auto-generated>
// <copyright>
//     Copyright (c) 2023 MetaFac
// </copyright>
// <information>
// This file was generated using MetaFac.CG4 tools and user supplied metadata.
// Generator: RecordsV2.3.1
// Metadata : MetaFac.CG4.Generators.UnitTests(.FlattenedModels)
// </information>
#endregion
#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable CS8019 // Unnecessary using directive
using MetaFac.Memory;
using MetaFac.Mutability;
using MetaFac.CG4.Runtime;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Numerics;
using Generated.Contracts;

namespace Generated.RecordsV2
{


    public abstract partial record EntityBase : IFreezable, IEntityBase
    {
        public EntityBase() { }
        public EntityBase(EntityBase? source) { }
        public EntityBase(IEntityBase? source) { }
        public const int EntityTag = 0;
        protected abstract int OnGetEntityTag();
        public int GetEntityTag() => OnGetEntityTag();
        public virtual bool Equals(EntityBase? other) => true;
        public override int GetHashCode() => 0;
        public bool IsFreezable() => false;
        public bool IsFrozen() => true;
        public void Freeze() { }
        public bool TryFreeze() => false;
    }


    public sealed class BuiltinTypes_Factory : IEntityFactory<IBuiltinTypes, BuiltinTypes>
    {
        private static readonly BuiltinTypes_Factory _instance = new BuiltinTypes_Factory();
        public static BuiltinTypes_Factory Instance => _instance;

        public BuiltinTypes? CreateFrom(IBuiltinTypes? source)
        {
            if (source is null) return null;
            if (source is BuiltinTypes thisEntity) return thisEntity;
            return new BuiltinTypes(source);
        }

        private static readonly BuiltinTypes _empty = new BuiltinTypes();
        public BuiltinTypes Empty => _empty;
    }
    public partial record BuiltinTypes : EntityBase, IBuiltinTypes
    {
        public new const int EntityTag = 1;
        protected override int OnGetEntityTag() => EntityTag;

        public ImmutableList<Boolean>? Bools { get; init; }
        IReadOnlyList<Boolean>? IBuiltinTypes.Bools => Bools;
        public ImmutableList<SByte>? SBytes { get; init; }
        IReadOnlyList<SByte>? IBuiltinTypes.SBytes => SBytes;
        public ImmutableList<Byte>? Bytes { get; init; }
        IReadOnlyList<Byte>? IBuiltinTypes.Bytes => Bytes;
        public ImmutableList<Int16>? Shorts { get; init; }
        IReadOnlyList<Int16>? IBuiltinTypes.Shorts => Shorts;
        public ImmutableList<UInt16>? UShorts { get; init; }
        IReadOnlyList<UInt16>? IBuiltinTypes.UShorts => UShorts;
        public ImmutableList<Char>? Chars { get; init; }
        IReadOnlyList<Char>? IBuiltinTypes.Chars => Chars;
        public ImmutableList<Int32>? Ints { get; init; }
        IReadOnlyList<Int32>? IBuiltinTypes.Ints => Ints;
        public ImmutableList<UInt32>? UInts { get; init; }
        IReadOnlyList<UInt32>? IBuiltinTypes.UInts => UInts;
        public ImmutableList<Single>? Floats { get; init; }
        IReadOnlyList<Single>? IBuiltinTypes.Floats => Floats;
        public ImmutableList<Int64>? Longs { get; init; }
        IReadOnlyList<Int64>? IBuiltinTypes.Longs => Longs;
        public ImmutableList<UInt64>? ULongs { get; init; }
        IReadOnlyList<UInt64>? IBuiltinTypes.ULongs => ULongs;
        public ImmutableList<Double>? Doubles { get; init; }
        IReadOnlyList<Double>? IBuiltinTypes.Doubles => Doubles;
        public ImmutableList<DateTime>? DateTimes { get; init; }
        IReadOnlyList<DateTime>? IBuiltinTypes.DateTimes => DateTimes;
        public ImmutableList<TimeSpan>? TimeSpans { get; init; }
        IReadOnlyList<TimeSpan>? IBuiltinTypes.TimeSpans => TimeSpans;
        public ImmutableList<Decimal>? Decimals { get; init; }
        IReadOnlyList<Decimal>? IBuiltinTypes.Decimals => Decimals;
        public ImmutableList<DateTimeOffset>? DateTimeOffsets { get; init; }
        IReadOnlyList<DateTimeOffset>? IBuiltinTypes.DateTimeOffsets => DateTimeOffsets;
        public ImmutableList<Guid>? Guids { get; init; }
        IReadOnlyList<Guid>? IBuiltinTypes.Guids => Guids;
        public ImmutableList<String?>? Strings { get; init; }
        IReadOnlyList<String?>? IBuiltinTypes.Strings => Strings;
        public ImmutableList<Octets?>? Buffers { get; init; }
        IReadOnlyList<Octets?>? IBuiltinTypes.Buffers => Buffers;
        public ImmutableList<LabApps.Units.Quantity>? Quantities { get; init; }
        IReadOnlyList<LabApps.Units.Quantity>? IBuiltinTypes.Quantities => Quantities;
        public ImmutableList<System.DayOfWeek>? DaysOfWeek { get; init; }
        IReadOnlyList<System.DayOfWeek>? IBuiltinTypes.DaysOfWeek => DaysOfWeek;
        public ImmutableList<System.DateTimeKind>? MyDateTimeKinds { get; init; }
        IReadOnlyList<System.DateTimeKind>? IBuiltinTypes.MyDateTimeKinds => MyDateTimeKinds;
        public ImmutableList<MyCustomEnum>? MyCustomEnums { get; init; }
        IReadOnlyList<MyCustomEnum>? IBuiltinTypes.MyCustomEnums => MyCustomEnums;
        public ImmutableList<Half>? Halves { get; init; }
        IReadOnlyList<Half>? IBuiltinTypes.Halves => Halves;
        public ImmutableList<DateOnly>? Dates { get; init; }
        IReadOnlyList<DateOnly>? IBuiltinTypes.Dates => Dates;
        public ImmutableList<TimeOnly>? Times { get; init; }
        IReadOnlyList<TimeOnly>? IBuiltinTypes.Times => Times;
        public ImmutableList<BigInteger>? BigInts { get; init; }
        IReadOnlyList<BigInteger>? IBuiltinTypes.BigInts => BigInts;
        public ImmutableList<Complex>? Complexes { get; init; }
        IReadOnlyList<Complex>? IBuiltinTypes.Complexes => Complexes;
        public ImmutableList<Version?>? Versions { get; init; }
        IReadOnlyList<Version?>? IBuiltinTypes.Versions => Versions;

        public BuiltinTypes() : base()
        {
        }

        public BuiltinTypes(BuiltinTypes? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Bools = source.Bools;
            SBytes = source.SBytes;
            Bytes = source.Bytes;
            Shorts = source.Shorts;
            UShorts = source.UShorts;
            Chars = source.Chars;
            Ints = source.Ints;
            UInts = source.UInts;
            Floats = source.Floats;
            Longs = source.Longs;
            ULongs = source.ULongs;
            Doubles = source.Doubles;
            DateTimes = source.DateTimes;
            TimeSpans = source.TimeSpans;
            Decimals = source.Decimals;
            DateTimeOffsets = source.DateTimeOffsets;
            Guids = source.Guids;
            Strings = source.Strings;
            Buffers = source.Buffers;
            Quantities = source.Quantities;
            DaysOfWeek = source.DaysOfWeek;
            MyDateTimeKinds = source.MyDateTimeKinds;
            MyCustomEnums = source.MyCustomEnums;
            Halves = source.Halves;
            Dates = source.Dates;
            Times = source.Times;
            BigInts = source.BigInts;
            Complexes = source.Complexes;
            Versions = source.Versions;
        }

        public BuiltinTypes(IBuiltinTypes? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Bools = source.Bools is null
                ? default
                : ImmutableList<Boolean>.Empty.AddRange(source.Bools);
            SBytes = source.SBytes is null
                ? default
                : ImmutableList<SByte>.Empty.AddRange(source.SBytes);
            Bytes = source.Bytes is null
                ? default
                : ImmutableList<Byte>.Empty.AddRange(source.Bytes);
            Shorts = source.Shorts is null
                ? default
                : ImmutableList<Int16>.Empty.AddRange(source.Shorts);
            UShorts = source.UShorts is null
                ? default
                : ImmutableList<UInt16>.Empty.AddRange(source.UShorts);
            Chars = source.Chars is null
                ? default
                : ImmutableList<Char>.Empty.AddRange(source.Chars);
            Ints = source.Ints is null
                ? default
                : ImmutableList<Int32>.Empty.AddRange(source.Ints);
            UInts = source.UInts is null
                ? default
                : ImmutableList<UInt32>.Empty.AddRange(source.UInts);
            Floats = source.Floats is null
                ? default
                : ImmutableList<Single>.Empty.AddRange(source.Floats);
            Longs = source.Longs is null
                ? default
                : ImmutableList<Int64>.Empty.AddRange(source.Longs);
            ULongs = source.ULongs is null
                ? default
                : ImmutableList<UInt64>.Empty.AddRange(source.ULongs);
            Doubles = source.Doubles is null
                ? default
                : ImmutableList<Double>.Empty.AddRange(source.Doubles);
            DateTimes = source.DateTimes is null
                ? default
                : ImmutableList<DateTime>.Empty.AddRange(source.DateTimes);
            TimeSpans = source.TimeSpans is null
                ? default
                : ImmutableList<TimeSpan>.Empty.AddRange(source.TimeSpans);
            Decimals = source.Decimals is null
                ? default
                : ImmutableList<Decimal>.Empty.AddRange(source.Decimals);
            DateTimeOffsets = source.DateTimeOffsets is null
                ? default
                : ImmutableList<DateTimeOffset>.Empty.AddRange(source.DateTimeOffsets);
            Guids = source.Guids is null
                ? default
                : ImmutableList<Guid>.Empty.AddRange(source.Guids);
            Strings = source.Strings is null
                ? default
                : ImmutableList<String?>.Empty.AddRange(source.Strings);
            Buffers = source.Buffers is null
                ? default
                : ImmutableList<Octets?>.Empty.AddRange(source.Buffers
                    .Select(x => (Octets?)x));
            Quantities = source.Quantities is null
                ? default
                : ImmutableList<LabApps.Units.Quantity>.Empty.AddRange(source.Quantities);
            DaysOfWeek = source.DaysOfWeek is null
                ? default
                : ImmutableList<System.DayOfWeek>.Empty.AddRange(source.DaysOfWeek);
            MyDateTimeKinds = source.MyDateTimeKinds is null
                ? default
                : ImmutableList<System.DateTimeKind>.Empty.AddRange(source.MyDateTimeKinds);
            MyCustomEnums = source.MyCustomEnums is null
                ? default
                : ImmutableList<MyCustomEnum>.Empty.AddRange(source.MyCustomEnums);
            Halves = source.Halves is null
                ? default
                : ImmutableList<Half>.Empty.AddRange(source.Halves);
            Dates = source.Dates is null
                ? default
                : ImmutableList<DateOnly>.Empty.AddRange(source.Dates);
            Times = source.Times is null
                ? default
                : ImmutableList<TimeOnly>.Empty.AddRange(source.Times);
            BigInts = source.BigInts is null
                ? default
                : ImmutableList<BigInteger>.Empty.AddRange(source.BigInts);
            Complexes = source.Complexes is null
                ? default
                : ImmutableList<Complex>.Empty.AddRange(source.Complexes);
            Versions = source.Versions is null
                ? default
                : ImmutableList<Version?>.Empty.AddRange(source.Versions);
        }

        public virtual bool Equals(BuiltinTypes? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Bools.ArrayEquals(other.Bools)) return false;
            if (!SBytes.ArrayEquals(other.SBytes)) return false;
            if (!Bytes.ArrayEquals(other.Bytes)) return false;
            if (!Shorts.ArrayEquals(other.Shorts)) return false;
            if (!UShorts.ArrayEquals(other.UShorts)) return false;
            if (!Chars.ArrayEquals(other.Chars)) return false;
            if (!Ints.ArrayEquals(other.Ints)) return false;
            if (!UInts.ArrayEquals(other.UInts)) return false;
            if (!Floats.ArrayEquals(other.Floats)) return false;
            if (!Longs.ArrayEquals(other.Longs)) return false;
            if (!ULongs.ArrayEquals(other.ULongs)) return false;
            if (!Doubles.ArrayEquals(other.Doubles)) return false;
            if (!DateTimes.ArrayEquals(other.DateTimes)) return false;
            if (!TimeSpans.ArrayEquals(other.TimeSpans)) return false;
            if (!Decimals.ArrayEquals(other.Decimals)) return false;
            if (!DateTimeOffsets.ArrayEquals(other.DateTimeOffsets)) return false;
            if (!Guids.ArrayEquals(other.Guids)) return false;
            if (!Strings.ArrayEquals(other.Strings)) return false;
            if (!Buffers.ArrayEquals(other.Buffers)) return false;
            if (!Quantities.ArrayEquals(other.Quantities)) return false;
            if (!DaysOfWeek.ArrayEquals(other.DaysOfWeek)) return false;
            if (!MyDateTimeKinds.ArrayEquals(other.MyDateTimeKinds)) return false;
            if (!MyCustomEnums.ArrayEquals(other.MyCustomEnums)) return false;
            if (!Halves.ArrayEquals(other.Halves)) return false;
            if (!Dates.ArrayEquals(other.Dates)) return false;
            if (!Times.ArrayEquals(other.Times)) return false;
            if (!BigInts.ArrayEquals(other.BigInts)) return false;
            if (!Complexes.ArrayEquals(other.Complexes)) return false;
            if (!Versions.ArrayEquals(other.Versions)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Bools.CalcHashArray());
            hc.Add(SBytes.CalcHashArray());
            hc.Add(Bytes.CalcHashArray());
            hc.Add(Shorts.CalcHashArray());
            hc.Add(UShorts.CalcHashArray());
            hc.Add(Chars.CalcHashArray());
            hc.Add(Ints.CalcHashArray());
            hc.Add(UInts.CalcHashArray());
            hc.Add(Floats.CalcHashArray());
            hc.Add(Longs.CalcHashArray());
            hc.Add(ULongs.CalcHashArray());
            hc.Add(Doubles.CalcHashArray());
            hc.Add(DateTimes.CalcHashArray());
            hc.Add(TimeSpans.CalcHashArray());
            hc.Add(Decimals.CalcHashArray());
            hc.Add(DateTimeOffsets.CalcHashArray());
            hc.Add(Guids.CalcHashArray());
            hc.Add(Strings.CalcHashArray());
            hc.Add(Buffers.CalcHashArray());
            hc.Add(Quantities.CalcHashArray());
            hc.Add(DaysOfWeek.CalcHashArray());
            hc.Add(MyDateTimeKinds.CalcHashArray());
            hc.Add(MyCustomEnums.CalcHashArray());
            hc.Add(Halves.CalcHashArray());
            hc.Add(Dates.CalcHashArray());
            hc.Add(Times.CalcHashArray());
            hc.Add(BigInts.CalcHashArray());
            hc.Add(Complexes.CalcHashArray());
            hc.Add(Versions.CalcHashArray());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }



}
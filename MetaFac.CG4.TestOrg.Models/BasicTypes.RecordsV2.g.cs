#region Notices
// <auto-generated>
// Warning: This file was automatically generated. Changes to this file may
// cause incorrect behavior and will be lost when this file is regenerated.
// </auto-generated>
// <information>
// This file was generated using MetaFac.CG4 tools and user supplied metadata.
// Generator: RecordsV2.2.0
// Metadata : MetaFac.CG4.TestOrg.Schema(.BasicTypes)
// </information>
#endregion
#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable CS8019 // Unnecessary using directive
using MetaFac.Memory;
using MetaFac.Mutability;
using MetaFac.CG4.Runtime;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Runtime.CompilerServices;
using MetaFac.CG4.TestOrg.Models.BasicTypes.Contracts;

namespace MetaFac.CG4.TestOrg.Models.BasicTypes.RecordsV2
{


    public abstract record EntityBase : IFreezable, IEntityBase
    {
        public EntityBase() { }
        public EntityBase(EntityBase? source) { }
        public EntityBase(IEntityBase? source) { }
        public const int EntityTag = 0;
        protected abstract int OnGetEntityTag();
        public int GetEntityTag() => OnGetEntityTag();
        public virtual bool Equals(EntityBase? other) => true;
        public override int GetHashCode() => 0;
        public static EntityBase Empty => throw new NotSupportedException();
        public bool IsFreezable() => false;
        public bool IsFrozen() => true;
        public void Freeze() { }
        public bool TryFreeze() => false;
    }


    public partial record Basic_bool
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_bool? CreateFrom(IBasic_bool? source)
        {
            if (source is null) return null;
            if (source is Basic_bool thisEntity) return thisEntity;
            return new Basic_bool(source);
        }

        private static readonly Basic_bool _empty = new Basic_bool();
        public static new Basic_bool Empty => _empty;

    }
    public partial record Basic_bool : EntityBase, IBasic_bool
    {
        public new const int EntityTag = 1;
        protected override int OnGetEntityTag() => EntityTag;

        public Boolean ScalarRequired { get; init; }
        Boolean IBasic_bool.ScalarRequired => ScalarRequired;
        public Boolean? ScalarOptional { get; init; }
        Boolean? IBasic_bool.ScalarOptional => ScalarOptional;
        public ImmutableList<Boolean>? VectorRequired { get; init; }
        IReadOnlyList<Boolean>? IBasic_bool.VectorRequired => VectorRequired;
        public ImmutableList<Boolean?>? VectorOptional { get; init; }
        IReadOnlyList<Boolean?>? IBasic_bool.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Boolean>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Boolean>? IBasic_bool.MapRequired => MapRequired;
        public ImmutableDictionary<String, Boolean?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Boolean?>? IBasic_bool.MapOptional => MapOptional;
        public ImmutableDictionary<Boolean, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Boolean, String?>? IBasic_bool.MapKey => MapKey;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_bool() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_bool(Basic_bool? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_bool(IBasic_bool? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Boolean>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Boolean?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Boolean>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Boolean?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Boolean, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_bool? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public partial record Basic_decimal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_decimal? CreateFrom(IBasic_decimal? source)
        {
            if (source is null) return null;
            if (source is Basic_decimal thisEntity) return thisEntity;
            return new Basic_decimal(source);
        }

        private static readonly Basic_decimal _empty = new Basic_decimal();
        public static new Basic_decimal Empty => _empty;

    }
    public partial record Basic_decimal : EntityBase, IBasic_decimal
    {
        public new const int EntityTag = 17;
        protected override int OnGetEntityTag() => EntityTag;

        public Decimal ScalarRequired { get; init; }
        Decimal IBasic_decimal.ScalarRequired => ScalarRequired;
        public Decimal? ScalarOptional { get; init; }
        Decimal? IBasic_decimal.ScalarOptional => ScalarOptional;
        public ImmutableList<Decimal>? VectorRequired { get; init; }
        IReadOnlyList<Decimal>? IBasic_decimal.VectorRequired => VectorRequired;
        public ImmutableList<Decimal?>? VectorOptional { get; init; }
        IReadOnlyList<Decimal?>? IBasic_decimal.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Decimal>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Decimal>? IBasic_decimal.MapRequired => MapRequired;
        public ImmutableDictionary<String, Decimal?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Decimal?>? IBasic_decimal.MapOptional => MapOptional;
        public ImmutableDictionary<Decimal, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Decimal, String?>? IBasic_decimal.MapKey => MapKey;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_decimal() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_decimal(Basic_decimal? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_decimal(IBasic_decimal? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Decimal>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Decimal?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Decimal>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Decimal?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Decimal, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_decimal? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public partial record Basic_DateTimeOffset
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_DateTimeOffset? CreateFrom(IBasic_DateTimeOffset? source)
        {
            if (source is null) return null;
            if (source is Basic_DateTimeOffset thisEntity) return thisEntity;
            return new Basic_DateTimeOffset(source);
        }

        private static readonly Basic_DateTimeOffset _empty = new Basic_DateTimeOffset();
        public static new Basic_DateTimeOffset Empty => _empty;

    }
    public partial record Basic_DateTimeOffset : EntityBase, IBasic_DateTimeOffset
    {
        public new const int EntityTag = 18;
        protected override int OnGetEntityTag() => EntityTag;

        public DateTimeOffset ScalarRequired { get; init; }
        DateTimeOffset IBasic_DateTimeOffset.ScalarRequired => ScalarRequired;
        public DateTimeOffset? ScalarOptional { get; init; }
        DateTimeOffset? IBasic_DateTimeOffset.ScalarOptional => ScalarOptional;
        public ImmutableList<DateTimeOffset>? VectorRequired { get; init; }
        IReadOnlyList<DateTimeOffset>? IBasic_DateTimeOffset.VectorRequired => VectorRequired;
        public ImmutableList<DateTimeOffset?>? VectorOptional { get; init; }
        IReadOnlyList<DateTimeOffset?>? IBasic_DateTimeOffset.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, DateTimeOffset>? MapRequired { get; init; }
        IReadOnlyDictionary<String, DateTimeOffset>? IBasic_DateTimeOffset.MapRequired => MapRequired;
        public ImmutableDictionary<String, DateTimeOffset?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, DateTimeOffset?>? IBasic_DateTimeOffset.MapOptional => MapOptional;
        public ImmutableDictionary<DateTimeOffset, String?>? MapKey { get; init; }
        IReadOnlyDictionary<DateTimeOffset, String?>? IBasic_DateTimeOffset.MapKey => MapKey;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DateTimeOffset() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DateTimeOffset(Basic_DateTimeOffset? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DateTimeOffset(IBasic_DateTimeOffset? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<DateTimeOffset>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<DateTimeOffset?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, DateTimeOffset>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, DateTimeOffset?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<DateTimeOffset, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_DateTimeOffset? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public partial record Basic_Guid
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_Guid? CreateFrom(IBasic_Guid? source)
        {
            if (source is null) return null;
            if (source is Basic_Guid thisEntity) return thisEntity;
            return new Basic_Guid(source);
        }

        private static readonly Basic_Guid _empty = new Basic_Guid();
        public static new Basic_Guid Empty => _empty;

    }
    public partial record Basic_Guid : EntityBase, IBasic_Guid
    {
        public new const int EntityTag = 19;
        protected override int OnGetEntityTag() => EntityTag;

        public Guid ScalarRequired { get; init; }
        Guid IBasic_Guid.ScalarRequired => ScalarRequired;
        public Guid? ScalarOptional { get; init; }
        Guid? IBasic_Guid.ScalarOptional => ScalarOptional;
        public ImmutableList<Guid>? VectorRequired { get; init; }
        IReadOnlyList<Guid>? IBasic_Guid.VectorRequired => VectorRequired;
        public ImmutableList<Guid?>? VectorOptional { get; init; }
        IReadOnlyList<Guid?>? IBasic_Guid.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Guid>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Guid>? IBasic_Guid.MapRequired => MapRequired;
        public ImmutableDictionary<String, Guid?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Guid?>? IBasic_Guid.MapOptional => MapOptional;
        public ImmutableDictionary<Guid, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Guid, String?>? IBasic_Guid.MapKey => MapKey;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Guid() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Guid(Basic_Guid? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Guid(IBasic_Guid? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Guid>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Guid?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Guid>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Guid?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Guid, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_Guid? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public partial record Basic_DayOfWeek
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_DayOfWeek? CreateFrom(IBasic_DayOfWeek? source)
        {
            if (source is null) return null;
            if (source is Basic_DayOfWeek thisEntity) return thisEntity;
            return new Basic_DayOfWeek(source);
        }

        private static readonly Basic_DayOfWeek _empty = new Basic_DayOfWeek();
        public static new Basic_DayOfWeek Empty => _empty;

    }
    public partial record Basic_DayOfWeek : EntityBase, IBasic_DayOfWeek
    {
        public new const int EntityTag = 20;
        protected override int OnGetEntityTag() => EntityTag;

        public System.DayOfWeek ScalarRequired { get; init; }
        System.DayOfWeek IBasic_DayOfWeek.ScalarRequired => ScalarRequired;
        public System.DayOfWeek? ScalarOptional { get; init; }
        System.DayOfWeek? IBasic_DayOfWeek.ScalarOptional => ScalarOptional;
        public ImmutableList<System.DayOfWeek>? VectorRequired { get; init; }
        IReadOnlyList<System.DayOfWeek>? IBasic_DayOfWeek.VectorRequired => VectorRequired;
        public ImmutableList<System.DayOfWeek?>? VectorOptional { get; init; }
        IReadOnlyList<System.DayOfWeek?>? IBasic_DayOfWeek.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, System.DayOfWeek>? MapRequired { get; init; }
        IReadOnlyDictionary<String, System.DayOfWeek>? IBasic_DayOfWeek.MapRequired => MapRequired;
        public ImmutableDictionary<String, System.DayOfWeek?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, System.DayOfWeek?>? IBasic_DayOfWeek.MapOptional => MapOptional;
        public ImmutableDictionary<System.DayOfWeek, String?>? MapKey { get; init; }
        IReadOnlyDictionary<System.DayOfWeek, String?>? IBasic_DayOfWeek.MapKey => MapKey;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DayOfWeek() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DayOfWeek(Basic_DayOfWeek? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DayOfWeek(IBasic_DayOfWeek? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<System.DayOfWeek>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<System.DayOfWeek?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, System.DayOfWeek>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, System.DayOfWeek?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<System.DayOfWeek, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_DayOfWeek? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public partial record Basic_MyCustomEnum
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_MyCustomEnum? CreateFrom(IBasic_MyCustomEnum? source)
        {
            if (source is null) return null;
            if (source is Basic_MyCustomEnum thisEntity) return thisEntity;
            return new Basic_MyCustomEnum(source);
        }

        private static readonly Basic_MyCustomEnum _empty = new Basic_MyCustomEnum();
        public static new Basic_MyCustomEnum Empty => _empty;

    }
    public partial record Basic_MyCustomEnum : EntityBase, IBasic_MyCustomEnum
    {
        public new const int EntityTag = 21;
        protected override int OnGetEntityTag() => EntityTag;

        public MyCustomEnum ScalarRequired { get; init; }
        MyCustomEnum IBasic_MyCustomEnum.ScalarRequired => ScalarRequired;
        public MyCustomEnum? ScalarOptional { get; init; }
        MyCustomEnum? IBasic_MyCustomEnum.ScalarOptional => ScalarOptional;
        public ImmutableList<MyCustomEnum>? VectorRequired { get; init; }
        IReadOnlyList<MyCustomEnum>? IBasic_MyCustomEnum.VectorRequired => VectorRequired;
        public ImmutableList<MyCustomEnum?>? VectorOptional { get; init; }
        IReadOnlyList<MyCustomEnum?>? IBasic_MyCustomEnum.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, MyCustomEnum>? MapRequired { get; init; }
        IReadOnlyDictionary<String, MyCustomEnum>? IBasic_MyCustomEnum.MapRequired => MapRequired;
        public ImmutableDictionary<String, MyCustomEnum?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, MyCustomEnum?>? IBasic_MyCustomEnum.MapOptional => MapOptional;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_MyCustomEnum() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_MyCustomEnum(Basic_MyCustomEnum? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_MyCustomEnum(IBasic_MyCustomEnum? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<MyCustomEnum>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<MyCustomEnum?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, MyCustomEnum>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, MyCustomEnum?>.Empty.AddRange(source.MapOptional);
        }

        public virtual bool Equals(Basic_MyCustomEnum? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public partial record Basic_string
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_string? CreateFrom(IBasic_string? source)
        {
            if (source is null) return null;
            if (source is Basic_string thisEntity) return thisEntity;
            return new Basic_string(source);
        }

        private static readonly Basic_string _empty = new Basic_string();
        public static new Basic_string Empty => _empty;

    }
    public partial record Basic_string : EntityBase, IBasic_string
    {
        public new const int EntityTag = 30;
        protected override int OnGetEntityTag() => EntityTag;

        public String? Scalar { get; init; }
        String? IBasic_string.Scalar => Scalar;
        public ImmutableList<String?>? Vector { get; init; }
        IReadOnlyList<String?>? IBasic_string.Vector => Vector;
        public ImmutableDictionary<String, String?>? MapValue { get; init; }
        IReadOnlyDictionary<String, String?>? IBasic_string.MapValue => MapValue;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_string() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_string(Basic_string? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Scalar = source.Scalar;
            Vector = source.Vector;
            MapValue = source.MapValue;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_string(IBasic_string? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Scalar = source.Scalar;
            Vector = source.Vector is null
                ? default
                : ImmutableList<String?>.Empty.AddRange(source.Vector);
            MapValue = source.MapValue is null
                ? default
                : ImmutableDictionary<String, String?>.Empty.AddRange(source.MapValue);
        }

        public virtual bool Equals(Basic_string? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Scalar.ValueEquals(other.Scalar)) return false;
            if (!Vector.ArrayEquals(other.Vector)) return false;
            if (!MapValue.IndexEquals(other.MapValue)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Scalar.CalcHashUnary());
            hc.Add(Vector.CalcHashArray());
            hc.Add(MapValue.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public partial record Basic_Octets
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_Octets? CreateFrom(IBasic_Octets? source)
        {
            if (source is null) return null;
            if (source is Basic_Octets thisEntity) return thisEntity;
            return new Basic_Octets(source);
        }

        private static readonly Basic_Octets _empty = new Basic_Octets();
        public static new Basic_Octets Empty => _empty;

    }
    public partial record Basic_Octets : EntityBase, IBasic_Octets
    {
        public new const int EntityTag = 31;
        protected override int OnGetEntityTag() => EntityTag;

        public Octets? Scalar { get; init; }
        Octets? IBasic_Octets.Scalar => Scalar;
        public ImmutableList<Octets?>? Vector { get; init; }
        IReadOnlyList<Octets?>? IBasic_Octets.Vector => Vector;
        public ImmutableDictionary<String, Octets?>? MapValue { get; init; }
        IReadOnlyDictionary<String, Octets?>? IBasic_Octets.MapValue => MapValue;
        public ImmutableDictionary<Octets, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Octets, String?>? IBasic_Octets.MapKey => MapKey;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Octets() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Octets(Basic_Octets? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Scalar = source.Scalar;
            Vector = source.Vector;
            MapValue = source.MapValue;
            MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Octets(IBasic_Octets? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Scalar = source.Scalar;
            Vector = source.Vector is null
                ? default
                : ImmutableList<Octets?>.Empty.AddRange(source.Vector
                    .Select(x => (Octets?)x));
            MapValue = source.MapValue is null
                ? default
                : ImmutableDictionary<String, Octets?>.Empty.AddRange(source.MapValue
                    .Select(x => new KeyValuePair<String, Octets?>(x.Key, x.Value)));
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Octets, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_Octets? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Scalar.ValueEquals(other.Scalar)) return false;
            if (!Vector.ArrayEquals(other.Vector)) return false;
            if (!MapValue.IndexEquals(other.MapValue)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Scalar.CalcHashUnary());
            hc.Add(Vector.CalcHashArray());
            hc.Add(MapValue.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }



}

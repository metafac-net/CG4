#region Notices
// <auto-generated>
// Warning: This file was automatically generated. Changes to this file may
// cause incorrect behavior and will be lost when this file is regenerated.
// </auto-generated>
// <information>
// This file was generated using MetaFac.CG4 tools and user supplied metadata.
// Generator: RecordsV2.2.8
// Metadata : MetaFac.CG4.TestOrg.Schema(.BasicTypes)
// </information>
#endregion
#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable CS8019 // Unnecessary using directive
using MetaFac.Memory;
using MetaFac.Mutability;
using MetaFac.CG4.Runtime;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Numerics;
using MetaFac.CG4.TestOrg.Models.BasicTypes.Contracts;

namespace MetaFac.CG4.TestOrg.Models.BasicTypes.RecordsV2
{


    public abstract record EntityBase : IFreezable, IEntityBase
    {
        public EntityBase() { }
        public EntityBase(EntityBase? source) { }
        public EntityBase(IEntityBase? source) { }
        public const int EntityTag = 0;
        protected abstract int OnGetEntityTag();
        public int GetEntityTag() => OnGetEntityTag();
        public virtual bool Equals(EntityBase? other) => true;
        public override int GetHashCode() => 0;
        public bool IsFreezable() => false;
        public bool IsFrozen() => true;
        public void Freeze() { }
        public bool TryFreeze() => false;
    }


    public sealed class Basic_bool_Factory : IEntityFactory<IBasic_bool, Basic_bool>
    {
        private static readonly Basic_bool_Factory _instance = new Basic_bool_Factory();
        public static Basic_bool_Factory Instance => _instance;

        public Basic_bool? CreateFrom(IBasic_bool? source)
        {
            if (source is null) return null;
            if (source is Basic_bool thisEntity) return thisEntity;
            return new Basic_bool(source);
        }

        private static readonly Basic_bool _empty = new Basic_bool();
        public Basic_bool Empty => _empty;
    }
    public partial record Basic_bool : EntityBase, IBasic_bool
    {
        public new const int EntityTag = 1;
        protected override int OnGetEntityTag() => EntityTag;

        public Boolean ScalarRequired { get; init; }
        Boolean IBasic_bool.ScalarRequired => ScalarRequired;
        public Boolean? ScalarOptional { get; init; }
        Boolean? IBasic_bool.ScalarOptional => ScalarOptional;
        public ImmutableList<Boolean>? VectorRequired { get; init; }
        IReadOnlyList<Boolean>? IBasic_bool.VectorRequired => VectorRequired;
        public ImmutableList<Boolean?>? VectorOptional { get; init; }
        IReadOnlyList<Boolean?>? IBasic_bool.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Boolean>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Boolean>? IBasic_bool.MapRequired => MapRequired;
        public ImmutableDictionary<String, Boolean?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Boolean?>? IBasic_bool.MapOptional => MapOptional;
        public ImmutableDictionary<Boolean, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Boolean, String?>? IBasic_bool.MapKey => MapKey;

        public Basic_bool() : base()
        {
        }

        public Basic_bool(Basic_bool? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_bool(IBasic_bool? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Boolean>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Boolean?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Boolean>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Boolean?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Boolean, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_bool? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_sbyte_Factory : IEntityFactory<IBasic_sbyte, Basic_sbyte>
    {
        private static readonly Basic_sbyte_Factory _instance = new Basic_sbyte_Factory();
        public static Basic_sbyte_Factory Instance => _instance;

        public Basic_sbyte? CreateFrom(IBasic_sbyte? source)
        {
            if (source is null) return null;
            if (source is Basic_sbyte thisEntity) return thisEntity;
            return new Basic_sbyte(source);
        }

        private static readonly Basic_sbyte _empty = new Basic_sbyte();
        public Basic_sbyte Empty => _empty;
    }
    public partial record Basic_sbyte : EntityBase, IBasic_sbyte
    {
        public new const int EntityTag = 2;
        protected override int OnGetEntityTag() => EntityTag;

        public SByte ScalarRequired { get; init; }
        SByte IBasic_sbyte.ScalarRequired => ScalarRequired;
        public SByte? ScalarOptional { get; init; }
        SByte? IBasic_sbyte.ScalarOptional => ScalarOptional;
        public ImmutableList<SByte>? VectorRequired { get; init; }
        IReadOnlyList<SByte>? IBasic_sbyte.VectorRequired => VectorRequired;
        public ImmutableList<SByte?>? VectorOptional { get; init; }
        IReadOnlyList<SByte?>? IBasic_sbyte.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, SByte>? MapRequired { get; init; }
        IReadOnlyDictionary<String, SByte>? IBasic_sbyte.MapRequired => MapRequired;
        public ImmutableDictionary<String, SByte?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, SByte?>? IBasic_sbyte.MapOptional => MapOptional;
        public ImmutableDictionary<SByte, String?>? MapKey { get; init; }
        IReadOnlyDictionary<SByte, String?>? IBasic_sbyte.MapKey => MapKey;

        public Basic_sbyte() : base()
        {
        }

        public Basic_sbyte(Basic_sbyte? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_sbyte(IBasic_sbyte? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<SByte>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<SByte?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, SByte>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, SByte?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<SByte, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_sbyte? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_byte_Factory : IEntityFactory<IBasic_byte, Basic_byte>
    {
        private static readonly Basic_byte_Factory _instance = new Basic_byte_Factory();
        public static Basic_byte_Factory Instance => _instance;

        public Basic_byte? CreateFrom(IBasic_byte? source)
        {
            if (source is null) return null;
            if (source is Basic_byte thisEntity) return thisEntity;
            return new Basic_byte(source);
        }

        private static readonly Basic_byte _empty = new Basic_byte();
        public Basic_byte Empty => _empty;
    }
    public partial record Basic_byte : EntityBase, IBasic_byte
    {
        public new const int EntityTag = 3;
        protected override int OnGetEntityTag() => EntityTag;

        public Byte ScalarRequired { get; init; }
        Byte IBasic_byte.ScalarRequired => ScalarRequired;
        public Byte? ScalarOptional { get; init; }
        Byte? IBasic_byte.ScalarOptional => ScalarOptional;
        public ImmutableList<Byte>? VectorRequired { get; init; }
        IReadOnlyList<Byte>? IBasic_byte.VectorRequired => VectorRequired;
        public ImmutableList<Byte?>? VectorOptional { get; init; }
        IReadOnlyList<Byte?>? IBasic_byte.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Byte>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Byte>? IBasic_byte.MapRequired => MapRequired;
        public ImmutableDictionary<String, Byte?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Byte?>? IBasic_byte.MapOptional => MapOptional;
        public ImmutableDictionary<Byte, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Byte, String?>? IBasic_byte.MapKey => MapKey;

        public Basic_byte() : base()
        {
        }

        public Basic_byte(Basic_byte? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_byte(IBasic_byte? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Byte>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Byte?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Byte>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Byte?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Byte, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_byte? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_short_Factory : IEntityFactory<IBasic_short, Basic_short>
    {
        private static readonly Basic_short_Factory _instance = new Basic_short_Factory();
        public static Basic_short_Factory Instance => _instance;

        public Basic_short? CreateFrom(IBasic_short? source)
        {
            if (source is null) return null;
            if (source is Basic_short thisEntity) return thisEntity;
            return new Basic_short(source);
        }

        private static readonly Basic_short _empty = new Basic_short();
        public Basic_short Empty => _empty;
    }
    public partial record Basic_short : EntityBase, IBasic_short
    {
        public new const int EntityTag = 4;
        protected override int OnGetEntityTag() => EntityTag;

        public Int16 ScalarRequired { get; init; }
        Int16 IBasic_short.ScalarRequired => ScalarRequired;
        public Int16? ScalarOptional { get; init; }
        Int16? IBasic_short.ScalarOptional => ScalarOptional;
        public ImmutableList<Int16>? VectorRequired { get; init; }
        IReadOnlyList<Int16>? IBasic_short.VectorRequired => VectorRequired;
        public ImmutableList<Int16?>? VectorOptional { get; init; }
        IReadOnlyList<Int16?>? IBasic_short.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Int16>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Int16>? IBasic_short.MapRequired => MapRequired;
        public ImmutableDictionary<String, Int16?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Int16?>? IBasic_short.MapOptional => MapOptional;
        public ImmutableDictionary<Int16, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Int16, String?>? IBasic_short.MapKey => MapKey;

        public Basic_short() : base()
        {
        }

        public Basic_short(Basic_short? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_short(IBasic_short? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Int16>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Int16?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Int16>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Int16?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Int16, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_short? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_ushort_Factory : IEntityFactory<IBasic_ushort, Basic_ushort>
    {
        private static readonly Basic_ushort_Factory _instance = new Basic_ushort_Factory();
        public static Basic_ushort_Factory Instance => _instance;

        public Basic_ushort? CreateFrom(IBasic_ushort? source)
        {
            if (source is null) return null;
            if (source is Basic_ushort thisEntity) return thisEntity;
            return new Basic_ushort(source);
        }

        private static readonly Basic_ushort _empty = new Basic_ushort();
        public Basic_ushort Empty => _empty;
    }
    public partial record Basic_ushort : EntityBase, IBasic_ushort
    {
        public new const int EntityTag = 5;
        protected override int OnGetEntityTag() => EntityTag;

        public UInt16 ScalarRequired { get; init; }
        UInt16 IBasic_ushort.ScalarRequired => ScalarRequired;
        public UInt16? ScalarOptional { get; init; }
        UInt16? IBasic_ushort.ScalarOptional => ScalarOptional;
        public ImmutableList<UInt16>? VectorRequired { get; init; }
        IReadOnlyList<UInt16>? IBasic_ushort.VectorRequired => VectorRequired;
        public ImmutableList<UInt16?>? VectorOptional { get; init; }
        IReadOnlyList<UInt16?>? IBasic_ushort.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, UInt16>? MapRequired { get; init; }
        IReadOnlyDictionary<String, UInt16>? IBasic_ushort.MapRequired => MapRequired;
        public ImmutableDictionary<String, UInt16?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, UInt16?>? IBasic_ushort.MapOptional => MapOptional;
        public ImmutableDictionary<UInt16, String?>? MapKey { get; init; }
        IReadOnlyDictionary<UInt16, String?>? IBasic_ushort.MapKey => MapKey;

        public Basic_ushort() : base()
        {
        }

        public Basic_ushort(Basic_ushort? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_ushort(IBasic_ushort? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<UInt16>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<UInt16?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, UInt16>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, UInt16?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<UInt16, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_ushort? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_char_Factory : IEntityFactory<IBasic_char, Basic_char>
    {
        private static readonly Basic_char_Factory _instance = new Basic_char_Factory();
        public static Basic_char_Factory Instance => _instance;

        public Basic_char? CreateFrom(IBasic_char? source)
        {
            if (source is null) return null;
            if (source is Basic_char thisEntity) return thisEntity;
            return new Basic_char(source);
        }

        private static readonly Basic_char _empty = new Basic_char();
        public Basic_char Empty => _empty;
    }
    public partial record Basic_char : EntityBase, IBasic_char
    {
        public new const int EntityTag = 6;
        protected override int OnGetEntityTag() => EntityTag;

        public Char ScalarRequired { get; init; }
        Char IBasic_char.ScalarRequired => ScalarRequired;
        public Char? ScalarOptional { get; init; }
        Char? IBasic_char.ScalarOptional => ScalarOptional;
        public ImmutableList<Char>? VectorRequired { get; init; }
        IReadOnlyList<Char>? IBasic_char.VectorRequired => VectorRequired;
        public ImmutableList<Char?>? VectorOptional { get; init; }
        IReadOnlyList<Char?>? IBasic_char.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Char>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Char>? IBasic_char.MapRequired => MapRequired;
        public ImmutableDictionary<String, Char?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Char?>? IBasic_char.MapOptional => MapOptional;
        public ImmutableDictionary<Char, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Char, String?>? IBasic_char.MapKey => MapKey;

        public Basic_char() : base()
        {
        }

        public Basic_char(Basic_char? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_char(IBasic_char? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Char>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Char?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Char>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Char?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Char, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_char? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_int_Factory : IEntityFactory<IBasic_int, Basic_int>
    {
        private static readonly Basic_int_Factory _instance = new Basic_int_Factory();
        public static Basic_int_Factory Instance => _instance;

        public Basic_int? CreateFrom(IBasic_int? source)
        {
            if (source is null) return null;
            if (source is Basic_int thisEntity) return thisEntity;
            return new Basic_int(source);
        }

        private static readonly Basic_int _empty = new Basic_int();
        public Basic_int Empty => _empty;
    }
    public partial record Basic_int : EntityBase, IBasic_int
    {
        public new const int EntityTag = 7;
        protected override int OnGetEntityTag() => EntityTag;

        public Int32 ScalarRequired { get; init; }
        Int32 IBasic_int.ScalarRequired => ScalarRequired;
        public Int32? ScalarOptional { get; init; }
        Int32? IBasic_int.ScalarOptional => ScalarOptional;
        public ImmutableList<Int32>? VectorRequired { get; init; }
        IReadOnlyList<Int32>? IBasic_int.VectorRequired => VectorRequired;
        public ImmutableList<Int32?>? VectorOptional { get; init; }
        IReadOnlyList<Int32?>? IBasic_int.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Int32>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Int32>? IBasic_int.MapRequired => MapRequired;
        public ImmutableDictionary<String, Int32?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Int32?>? IBasic_int.MapOptional => MapOptional;
        public ImmutableDictionary<Int32, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Int32, String?>? IBasic_int.MapKey => MapKey;

        public Basic_int() : base()
        {
        }

        public Basic_int(Basic_int? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_int(IBasic_int? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Int32>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Int32?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Int32>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Int32?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Int32, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_int? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_uint_Factory : IEntityFactory<IBasic_uint, Basic_uint>
    {
        private static readonly Basic_uint_Factory _instance = new Basic_uint_Factory();
        public static Basic_uint_Factory Instance => _instance;

        public Basic_uint? CreateFrom(IBasic_uint? source)
        {
            if (source is null) return null;
            if (source is Basic_uint thisEntity) return thisEntity;
            return new Basic_uint(source);
        }

        private static readonly Basic_uint _empty = new Basic_uint();
        public Basic_uint Empty => _empty;
    }
    public partial record Basic_uint : EntityBase, IBasic_uint
    {
        public new const int EntityTag = 8;
        protected override int OnGetEntityTag() => EntityTag;

        public UInt32 ScalarRequired { get; init; }
        UInt32 IBasic_uint.ScalarRequired => ScalarRequired;
        public UInt32? ScalarOptional { get; init; }
        UInt32? IBasic_uint.ScalarOptional => ScalarOptional;
        public ImmutableList<UInt32>? VectorRequired { get; init; }
        IReadOnlyList<UInt32>? IBasic_uint.VectorRequired => VectorRequired;
        public ImmutableList<UInt32?>? VectorOptional { get; init; }
        IReadOnlyList<UInt32?>? IBasic_uint.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, UInt32>? MapRequired { get; init; }
        IReadOnlyDictionary<String, UInt32>? IBasic_uint.MapRequired => MapRequired;
        public ImmutableDictionary<String, UInt32?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, UInt32?>? IBasic_uint.MapOptional => MapOptional;
        public ImmutableDictionary<UInt32, String?>? MapKey { get; init; }
        IReadOnlyDictionary<UInt32, String?>? IBasic_uint.MapKey => MapKey;

        public Basic_uint() : base()
        {
        }

        public Basic_uint(Basic_uint? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_uint(IBasic_uint? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<UInt32>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<UInt32?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, UInt32>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, UInt32?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<UInt32, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_uint? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_float_Factory : IEntityFactory<IBasic_float, Basic_float>
    {
        private static readonly Basic_float_Factory _instance = new Basic_float_Factory();
        public static Basic_float_Factory Instance => _instance;

        public Basic_float? CreateFrom(IBasic_float? source)
        {
            if (source is null) return null;
            if (source is Basic_float thisEntity) return thisEntity;
            return new Basic_float(source);
        }

        private static readonly Basic_float _empty = new Basic_float();
        public Basic_float Empty => _empty;
    }
    public partial record Basic_float : EntityBase, IBasic_float
    {
        public new const int EntityTag = 9;
        protected override int OnGetEntityTag() => EntityTag;

        public Single ScalarRequired { get; init; }
        Single IBasic_float.ScalarRequired => ScalarRequired;
        public Single? ScalarOptional { get; init; }
        Single? IBasic_float.ScalarOptional => ScalarOptional;
        public ImmutableList<Single>? VectorRequired { get; init; }
        IReadOnlyList<Single>? IBasic_float.VectorRequired => VectorRequired;
        public ImmutableList<Single?>? VectorOptional { get; init; }
        IReadOnlyList<Single?>? IBasic_float.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Single>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Single>? IBasic_float.MapRequired => MapRequired;
        public ImmutableDictionary<String, Single?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Single?>? IBasic_float.MapOptional => MapOptional;
        public ImmutableDictionary<Single, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Single, String?>? IBasic_float.MapKey => MapKey;

        public Basic_float() : base()
        {
        }

        public Basic_float(Basic_float? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_float(IBasic_float? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Single>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Single?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Single>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Single?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Single, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_float? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_long_Factory : IEntityFactory<IBasic_long, Basic_long>
    {
        private static readonly Basic_long_Factory _instance = new Basic_long_Factory();
        public static Basic_long_Factory Instance => _instance;

        public Basic_long? CreateFrom(IBasic_long? source)
        {
            if (source is null) return null;
            if (source is Basic_long thisEntity) return thisEntity;
            return new Basic_long(source);
        }

        private static readonly Basic_long _empty = new Basic_long();
        public Basic_long Empty => _empty;
    }
    public partial record Basic_long : EntityBase, IBasic_long
    {
        public new const int EntityTag = 10;
        protected override int OnGetEntityTag() => EntityTag;

        public Int64 ScalarRequired { get; init; }
        Int64 IBasic_long.ScalarRequired => ScalarRequired;
        public Int64? ScalarOptional { get; init; }
        Int64? IBasic_long.ScalarOptional => ScalarOptional;
        public ImmutableList<Int64>? VectorRequired { get; init; }
        IReadOnlyList<Int64>? IBasic_long.VectorRequired => VectorRequired;
        public ImmutableList<Int64?>? VectorOptional { get; init; }
        IReadOnlyList<Int64?>? IBasic_long.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Int64>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Int64>? IBasic_long.MapRequired => MapRequired;
        public ImmutableDictionary<String, Int64?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Int64?>? IBasic_long.MapOptional => MapOptional;
        public ImmutableDictionary<Int64, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Int64, String?>? IBasic_long.MapKey => MapKey;

        public Basic_long() : base()
        {
        }

        public Basic_long(Basic_long? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_long(IBasic_long? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Int64>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Int64?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Int64>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Int64?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Int64, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_long? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_ulong_Factory : IEntityFactory<IBasic_ulong, Basic_ulong>
    {
        private static readonly Basic_ulong_Factory _instance = new Basic_ulong_Factory();
        public static Basic_ulong_Factory Instance => _instance;

        public Basic_ulong? CreateFrom(IBasic_ulong? source)
        {
            if (source is null) return null;
            if (source is Basic_ulong thisEntity) return thisEntity;
            return new Basic_ulong(source);
        }

        private static readonly Basic_ulong _empty = new Basic_ulong();
        public Basic_ulong Empty => _empty;
    }
    public partial record Basic_ulong : EntityBase, IBasic_ulong
    {
        public new const int EntityTag = 11;
        protected override int OnGetEntityTag() => EntityTag;

        public UInt64 ScalarRequired { get; init; }
        UInt64 IBasic_ulong.ScalarRequired => ScalarRequired;
        public UInt64? ScalarOptional { get; init; }
        UInt64? IBasic_ulong.ScalarOptional => ScalarOptional;
        public ImmutableList<UInt64>? VectorRequired { get; init; }
        IReadOnlyList<UInt64>? IBasic_ulong.VectorRequired => VectorRequired;
        public ImmutableList<UInt64?>? VectorOptional { get; init; }
        IReadOnlyList<UInt64?>? IBasic_ulong.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, UInt64>? MapRequired { get; init; }
        IReadOnlyDictionary<String, UInt64>? IBasic_ulong.MapRequired => MapRequired;
        public ImmutableDictionary<String, UInt64?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, UInt64?>? IBasic_ulong.MapOptional => MapOptional;
        public ImmutableDictionary<UInt64, String?>? MapKey { get; init; }
        IReadOnlyDictionary<UInt64, String?>? IBasic_ulong.MapKey => MapKey;

        public Basic_ulong() : base()
        {
        }

        public Basic_ulong(Basic_ulong? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_ulong(IBasic_ulong? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<UInt64>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<UInt64?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, UInt64>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, UInt64?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<UInt64, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_ulong? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_double_Factory : IEntityFactory<IBasic_double, Basic_double>
    {
        private static readonly Basic_double_Factory _instance = new Basic_double_Factory();
        public static Basic_double_Factory Instance => _instance;

        public Basic_double? CreateFrom(IBasic_double? source)
        {
            if (source is null) return null;
            if (source is Basic_double thisEntity) return thisEntity;
            return new Basic_double(source);
        }

        private static readonly Basic_double _empty = new Basic_double();
        public Basic_double Empty => _empty;
    }
    public partial record Basic_double : EntityBase, IBasic_double
    {
        public new const int EntityTag = 12;
        protected override int OnGetEntityTag() => EntityTag;

        public Double ScalarRequired { get; init; }
        Double IBasic_double.ScalarRequired => ScalarRequired;
        public Double? ScalarOptional { get; init; }
        Double? IBasic_double.ScalarOptional => ScalarOptional;
        public ImmutableList<Double>? VectorRequired { get; init; }
        IReadOnlyList<Double>? IBasic_double.VectorRequired => VectorRequired;
        public ImmutableList<Double?>? VectorOptional { get; init; }
        IReadOnlyList<Double?>? IBasic_double.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Double>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Double>? IBasic_double.MapRequired => MapRequired;
        public ImmutableDictionary<String, Double?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Double?>? IBasic_double.MapOptional => MapOptional;
        public ImmutableDictionary<Double, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Double, String?>? IBasic_double.MapKey => MapKey;

        public Basic_double() : base()
        {
        }

        public Basic_double(Basic_double? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_double(IBasic_double? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Double>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Double?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Double>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Double?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Double, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_double? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_DateTime_Factory : IEntityFactory<IBasic_DateTime, Basic_DateTime>
    {
        private static readonly Basic_DateTime_Factory _instance = new Basic_DateTime_Factory();
        public static Basic_DateTime_Factory Instance => _instance;

        public Basic_DateTime? CreateFrom(IBasic_DateTime? source)
        {
            if (source is null) return null;
            if (source is Basic_DateTime thisEntity) return thisEntity;
            return new Basic_DateTime(source);
        }

        private static readonly Basic_DateTime _empty = new Basic_DateTime();
        public Basic_DateTime Empty => _empty;
    }
    public partial record Basic_DateTime : EntityBase, IBasic_DateTime
    {
        public new const int EntityTag = 13;
        protected override int OnGetEntityTag() => EntityTag;

        public DateTime ScalarRequired { get; init; }
        DateTime IBasic_DateTime.ScalarRequired => ScalarRequired;
        public DateTime? ScalarOptional { get; init; }
        DateTime? IBasic_DateTime.ScalarOptional => ScalarOptional;
        public ImmutableList<DateTime>? VectorRequired { get; init; }
        IReadOnlyList<DateTime>? IBasic_DateTime.VectorRequired => VectorRequired;
        public ImmutableList<DateTime?>? VectorOptional { get; init; }
        IReadOnlyList<DateTime?>? IBasic_DateTime.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, DateTime>? MapRequired { get; init; }
        IReadOnlyDictionary<String, DateTime>? IBasic_DateTime.MapRequired => MapRequired;
        public ImmutableDictionary<String, DateTime?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, DateTime?>? IBasic_DateTime.MapOptional => MapOptional;
        public ImmutableDictionary<DateTime, String?>? MapKey { get; init; }
        IReadOnlyDictionary<DateTime, String?>? IBasic_DateTime.MapKey => MapKey;

        public Basic_DateTime() : base()
        {
        }

        public Basic_DateTime(Basic_DateTime? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_DateTime(IBasic_DateTime? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<DateTime>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<DateTime?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, DateTime>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, DateTime?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<DateTime, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_DateTime? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_TimeSpan_Factory : IEntityFactory<IBasic_TimeSpan, Basic_TimeSpan>
    {
        private static readonly Basic_TimeSpan_Factory _instance = new Basic_TimeSpan_Factory();
        public static Basic_TimeSpan_Factory Instance => _instance;

        public Basic_TimeSpan? CreateFrom(IBasic_TimeSpan? source)
        {
            if (source is null) return null;
            if (source is Basic_TimeSpan thisEntity) return thisEntity;
            return new Basic_TimeSpan(source);
        }

        private static readonly Basic_TimeSpan _empty = new Basic_TimeSpan();
        public Basic_TimeSpan Empty => _empty;
    }
    public partial record Basic_TimeSpan : EntityBase, IBasic_TimeSpan
    {
        public new const int EntityTag = 14;
        protected override int OnGetEntityTag() => EntityTag;

        public TimeSpan ScalarRequired { get; init; }
        TimeSpan IBasic_TimeSpan.ScalarRequired => ScalarRequired;
        public TimeSpan? ScalarOptional { get; init; }
        TimeSpan? IBasic_TimeSpan.ScalarOptional => ScalarOptional;
        public ImmutableList<TimeSpan>? VectorRequired { get; init; }
        IReadOnlyList<TimeSpan>? IBasic_TimeSpan.VectorRequired => VectorRequired;
        public ImmutableList<TimeSpan?>? VectorOptional { get; init; }
        IReadOnlyList<TimeSpan?>? IBasic_TimeSpan.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, TimeSpan>? MapRequired { get; init; }
        IReadOnlyDictionary<String, TimeSpan>? IBasic_TimeSpan.MapRequired => MapRequired;
        public ImmutableDictionary<String, TimeSpan?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, TimeSpan?>? IBasic_TimeSpan.MapOptional => MapOptional;
        public ImmutableDictionary<TimeSpan, String?>? MapKey { get; init; }
        IReadOnlyDictionary<TimeSpan, String?>? IBasic_TimeSpan.MapKey => MapKey;

        public Basic_TimeSpan() : base()
        {
        }

        public Basic_TimeSpan(Basic_TimeSpan? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_TimeSpan(IBasic_TimeSpan? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<TimeSpan>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<TimeSpan?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, TimeSpan>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, TimeSpan?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<TimeSpan, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_TimeSpan? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_decimal_Factory : IEntityFactory<IBasic_decimal, Basic_decimal>
    {
        private static readonly Basic_decimal_Factory _instance = new Basic_decimal_Factory();
        public static Basic_decimal_Factory Instance => _instance;

        public Basic_decimal? CreateFrom(IBasic_decimal? source)
        {
            if (source is null) return null;
            if (source is Basic_decimal thisEntity) return thisEntity;
            return new Basic_decimal(source);
        }

        private static readonly Basic_decimal _empty = new Basic_decimal();
        public Basic_decimal Empty => _empty;
    }
    public partial record Basic_decimal : EntityBase, IBasic_decimal
    {
        public new const int EntityTag = 17;
        protected override int OnGetEntityTag() => EntityTag;

        public Decimal ScalarRequired { get; init; }
        Decimal IBasic_decimal.ScalarRequired => ScalarRequired;
        public Decimal? ScalarOptional { get; init; }
        Decimal? IBasic_decimal.ScalarOptional => ScalarOptional;
        public ImmutableList<Decimal>? VectorRequired { get; init; }
        IReadOnlyList<Decimal>? IBasic_decimal.VectorRequired => VectorRequired;
        public ImmutableList<Decimal?>? VectorOptional { get; init; }
        IReadOnlyList<Decimal?>? IBasic_decimal.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Decimal>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Decimal>? IBasic_decimal.MapRequired => MapRequired;
        public ImmutableDictionary<String, Decimal?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Decimal?>? IBasic_decimal.MapOptional => MapOptional;
        public ImmutableDictionary<Decimal, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Decimal, String?>? IBasic_decimal.MapKey => MapKey;

        public Basic_decimal() : base()
        {
        }

        public Basic_decimal(Basic_decimal? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_decimal(IBasic_decimal? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Decimal>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Decimal?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Decimal>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Decimal?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Decimal, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_decimal? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_DateTimeOffset_Factory : IEntityFactory<IBasic_DateTimeOffset, Basic_DateTimeOffset>
    {
        private static readonly Basic_DateTimeOffset_Factory _instance = new Basic_DateTimeOffset_Factory();
        public static Basic_DateTimeOffset_Factory Instance => _instance;

        public Basic_DateTimeOffset? CreateFrom(IBasic_DateTimeOffset? source)
        {
            if (source is null) return null;
            if (source is Basic_DateTimeOffset thisEntity) return thisEntity;
            return new Basic_DateTimeOffset(source);
        }

        private static readonly Basic_DateTimeOffset _empty = new Basic_DateTimeOffset();
        public Basic_DateTimeOffset Empty => _empty;
    }
    public partial record Basic_DateTimeOffset : EntityBase, IBasic_DateTimeOffset
    {
        public new const int EntityTag = 18;
        protected override int OnGetEntityTag() => EntityTag;

        public DateTimeOffset ScalarRequired { get; init; }
        DateTimeOffset IBasic_DateTimeOffset.ScalarRequired => ScalarRequired;
        public DateTimeOffset? ScalarOptional { get; init; }
        DateTimeOffset? IBasic_DateTimeOffset.ScalarOptional => ScalarOptional;
        public ImmutableList<DateTimeOffset>? VectorRequired { get; init; }
        IReadOnlyList<DateTimeOffset>? IBasic_DateTimeOffset.VectorRequired => VectorRequired;
        public ImmutableList<DateTimeOffset?>? VectorOptional { get; init; }
        IReadOnlyList<DateTimeOffset?>? IBasic_DateTimeOffset.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, DateTimeOffset>? MapRequired { get; init; }
        IReadOnlyDictionary<String, DateTimeOffset>? IBasic_DateTimeOffset.MapRequired => MapRequired;
        public ImmutableDictionary<String, DateTimeOffset?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, DateTimeOffset?>? IBasic_DateTimeOffset.MapOptional => MapOptional;
        public ImmutableDictionary<DateTimeOffset, String?>? MapKey { get; init; }
        IReadOnlyDictionary<DateTimeOffset, String?>? IBasic_DateTimeOffset.MapKey => MapKey;

        public Basic_DateTimeOffset() : base()
        {
        }

        public Basic_DateTimeOffset(Basic_DateTimeOffset? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_DateTimeOffset(IBasic_DateTimeOffset? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<DateTimeOffset>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<DateTimeOffset?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, DateTimeOffset>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, DateTimeOffset?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<DateTimeOffset, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_DateTimeOffset? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_Guid_Factory : IEntityFactory<IBasic_Guid, Basic_Guid>
    {
        private static readonly Basic_Guid_Factory _instance = new Basic_Guid_Factory();
        public static Basic_Guid_Factory Instance => _instance;

        public Basic_Guid? CreateFrom(IBasic_Guid? source)
        {
            if (source is null) return null;
            if (source is Basic_Guid thisEntity) return thisEntity;
            return new Basic_Guid(source);
        }

        private static readonly Basic_Guid _empty = new Basic_Guid();
        public Basic_Guid Empty => _empty;
    }
    public partial record Basic_Guid : EntityBase, IBasic_Guid
    {
        public new const int EntityTag = 19;
        protected override int OnGetEntityTag() => EntityTag;

        public Guid ScalarRequired { get; init; }
        Guid IBasic_Guid.ScalarRequired => ScalarRequired;
        public Guid? ScalarOptional { get; init; }
        Guid? IBasic_Guid.ScalarOptional => ScalarOptional;
        public ImmutableList<Guid>? VectorRequired { get; init; }
        IReadOnlyList<Guid>? IBasic_Guid.VectorRequired => VectorRequired;
        public ImmutableList<Guid?>? VectorOptional { get; init; }
        IReadOnlyList<Guid?>? IBasic_Guid.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Guid>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Guid>? IBasic_Guid.MapRequired => MapRequired;
        public ImmutableDictionary<String, Guid?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Guid?>? IBasic_Guid.MapOptional => MapOptional;
        public ImmutableDictionary<Guid, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Guid, String?>? IBasic_Guid.MapKey => MapKey;

        public Basic_Guid() : base()
        {
        }

        public Basic_Guid(Basic_Guid? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_Guid(IBasic_Guid? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Guid>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Guid?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Guid>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Guid?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Guid, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_Guid? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_DayOfWeek_Factory : IEntityFactory<IBasic_DayOfWeek, Basic_DayOfWeek>
    {
        private static readonly Basic_DayOfWeek_Factory _instance = new Basic_DayOfWeek_Factory();
        public static Basic_DayOfWeek_Factory Instance => _instance;

        public Basic_DayOfWeek? CreateFrom(IBasic_DayOfWeek? source)
        {
            if (source is null) return null;
            if (source is Basic_DayOfWeek thisEntity) return thisEntity;
            return new Basic_DayOfWeek(source);
        }

        private static readonly Basic_DayOfWeek _empty = new Basic_DayOfWeek();
        public Basic_DayOfWeek Empty => _empty;
    }
    public partial record Basic_DayOfWeek : EntityBase, IBasic_DayOfWeek
    {
        public new const int EntityTag = 20;
        protected override int OnGetEntityTag() => EntityTag;

        public System.DayOfWeek ScalarRequired { get; init; }
        System.DayOfWeek IBasic_DayOfWeek.ScalarRequired => ScalarRequired;
        public System.DayOfWeek? ScalarOptional { get; init; }
        System.DayOfWeek? IBasic_DayOfWeek.ScalarOptional => ScalarOptional;
        public ImmutableList<System.DayOfWeek>? VectorRequired { get; init; }
        IReadOnlyList<System.DayOfWeek>? IBasic_DayOfWeek.VectorRequired => VectorRequired;
        public ImmutableList<System.DayOfWeek?>? VectorOptional { get; init; }
        IReadOnlyList<System.DayOfWeek?>? IBasic_DayOfWeek.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, System.DayOfWeek>? MapRequired { get; init; }
        IReadOnlyDictionary<String, System.DayOfWeek>? IBasic_DayOfWeek.MapRequired => MapRequired;
        public ImmutableDictionary<String, System.DayOfWeek?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, System.DayOfWeek?>? IBasic_DayOfWeek.MapOptional => MapOptional;
        public ImmutableDictionary<System.DayOfWeek, String?>? MapKey { get; init; }
        IReadOnlyDictionary<System.DayOfWeek, String?>? IBasic_DayOfWeek.MapKey => MapKey;

        public Basic_DayOfWeek() : base()
        {
        }

        public Basic_DayOfWeek(Basic_DayOfWeek? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_DayOfWeek(IBasic_DayOfWeek? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<System.DayOfWeek>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<System.DayOfWeek?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, System.DayOfWeek>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, System.DayOfWeek?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<System.DayOfWeek, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_DayOfWeek? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_MyCustomEnum_Factory : IEntityFactory<IBasic_MyCustomEnum, Basic_MyCustomEnum>
    {
        private static readonly Basic_MyCustomEnum_Factory _instance = new Basic_MyCustomEnum_Factory();
        public static Basic_MyCustomEnum_Factory Instance => _instance;

        public Basic_MyCustomEnum? CreateFrom(IBasic_MyCustomEnum? source)
        {
            if (source is null) return null;
            if (source is Basic_MyCustomEnum thisEntity) return thisEntity;
            return new Basic_MyCustomEnum(source);
        }

        private static readonly Basic_MyCustomEnum _empty = new Basic_MyCustomEnum();
        public Basic_MyCustomEnum Empty => _empty;
    }
    public partial record Basic_MyCustomEnum : EntityBase, IBasic_MyCustomEnum
    {
        public new const int EntityTag = 21;
        protected override int OnGetEntityTag() => EntityTag;

        public MyCustomEnum ScalarRequired { get; init; }
        MyCustomEnum IBasic_MyCustomEnum.ScalarRequired => ScalarRequired;
        public MyCustomEnum? ScalarOptional { get; init; }
        MyCustomEnum? IBasic_MyCustomEnum.ScalarOptional => ScalarOptional;
        public ImmutableList<MyCustomEnum>? VectorRequired { get; init; }
        IReadOnlyList<MyCustomEnum>? IBasic_MyCustomEnum.VectorRequired => VectorRequired;
        public ImmutableList<MyCustomEnum?>? VectorOptional { get; init; }
        IReadOnlyList<MyCustomEnum?>? IBasic_MyCustomEnum.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, MyCustomEnum>? MapRequired { get; init; }
        IReadOnlyDictionary<String, MyCustomEnum>? IBasic_MyCustomEnum.MapRequired => MapRequired;
        public ImmutableDictionary<String, MyCustomEnum?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, MyCustomEnum?>? IBasic_MyCustomEnum.MapOptional => MapOptional;
        public ImmutableDictionary<MyCustomEnum, String?>? MapKey { get; init; }
        IReadOnlyDictionary<MyCustomEnum, String?>? IBasic_MyCustomEnum.MapKey => MapKey;

        public Basic_MyCustomEnum() : base()
        {
        }

        public Basic_MyCustomEnum(Basic_MyCustomEnum? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_MyCustomEnum(IBasic_MyCustomEnum? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<MyCustomEnum>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<MyCustomEnum?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, MyCustomEnum>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, MyCustomEnum?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<MyCustomEnum, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_MyCustomEnum? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_Quantity_Factory : IEntityFactory<IBasic_Quantity, Basic_Quantity>
    {
        private static readonly Basic_Quantity_Factory _instance = new Basic_Quantity_Factory();
        public static Basic_Quantity_Factory Instance => _instance;

        public Basic_Quantity? CreateFrom(IBasic_Quantity? source)
        {
            if (source is null) return null;
            if (source is Basic_Quantity thisEntity) return thisEntity;
            return new Basic_Quantity(source);
        }

        private static readonly Basic_Quantity _empty = new Basic_Quantity();
        public Basic_Quantity Empty => _empty;
    }
    public partial record Basic_Quantity : EntityBase, IBasic_Quantity
    {
        public new const int EntityTag = 22;
        protected override int OnGetEntityTag() => EntityTag;

        public LabApps.Units.Quantity ScalarRequired { get; init; }
        LabApps.Units.Quantity IBasic_Quantity.ScalarRequired => ScalarRequired;
        public LabApps.Units.Quantity? ScalarOptional { get; init; }
        LabApps.Units.Quantity? IBasic_Quantity.ScalarOptional => ScalarOptional;
        public ImmutableList<LabApps.Units.Quantity>? VectorRequired { get; init; }
        IReadOnlyList<LabApps.Units.Quantity>? IBasic_Quantity.VectorRequired => VectorRequired;
        public ImmutableList<LabApps.Units.Quantity?>? VectorOptional { get; init; }
        IReadOnlyList<LabApps.Units.Quantity?>? IBasic_Quantity.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, LabApps.Units.Quantity>? MapRequired { get; init; }
        IReadOnlyDictionary<String, LabApps.Units.Quantity>? IBasic_Quantity.MapRequired => MapRequired;
        public ImmutableDictionary<String, LabApps.Units.Quantity?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, LabApps.Units.Quantity?>? IBasic_Quantity.MapOptional => MapOptional;

        public Basic_Quantity() : base()
        {
        }

        public Basic_Quantity(Basic_Quantity? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
        }

        public Basic_Quantity(IBasic_Quantity? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<LabApps.Units.Quantity>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<LabApps.Units.Quantity?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, LabApps.Units.Quantity>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, LabApps.Units.Quantity?>.Empty.AddRange(source.MapOptional);
        }

        public virtual bool Equals(Basic_Quantity? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_string_Factory : IEntityFactory<IBasic_string, Basic_string>
    {
        private static readonly Basic_string_Factory _instance = new Basic_string_Factory();
        public static Basic_string_Factory Instance => _instance;

        public Basic_string? CreateFrom(IBasic_string? source)
        {
            if (source is null) return null;
            if (source is Basic_string thisEntity) return thisEntity;
            return new Basic_string(source);
        }

        private static readonly Basic_string _empty = new Basic_string();
        public Basic_string Empty => _empty;
    }
    public partial record Basic_string : EntityBase, IBasic_string
    {
        public new const int EntityTag = 30;
        protected override int OnGetEntityTag() => EntityTag;

        public String? Scalar { get; init; }
        String? IBasic_string.Scalar => Scalar;
        public ImmutableList<String?>? Vector { get; init; }
        IReadOnlyList<String?>? IBasic_string.Vector => Vector;
        public ImmutableDictionary<String, String?>? MapValue { get; init; }
        IReadOnlyDictionary<String, String?>? IBasic_string.MapValue => MapValue;

        public Basic_string() : base()
        {
        }

        public Basic_string(Basic_string? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Scalar = source.Scalar;
            Vector = source.Vector;
            MapValue = source.MapValue;
        }

        public Basic_string(IBasic_string? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Scalar = source.Scalar;
            Vector = source.Vector is null
                ? default
                : ImmutableList<String?>.Empty.AddRange(source.Vector);
            MapValue = source.MapValue is null
                ? default
                : ImmutableDictionary<String, String?>.Empty.AddRange(source.MapValue);
        }

        public virtual bool Equals(Basic_string? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Scalar.ValueEquals(other.Scalar)) return false;
            if (!Vector.ArrayEquals(other.Vector)) return false;
            if (!MapValue.IndexEquals(other.MapValue)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Scalar.CalcHashUnary());
            hc.Add(Vector.CalcHashArray());
            hc.Add(MapValue.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_Octets_Factory : IEntityFactory<IBasic_Octets, Basic_Octets>
    {
        private static readonly Basic_Octets_Factory _instance = new Basic_Octets_Factory();
        public static Basic_Octets_Factory Instance => _instance;

        public Basic_Octets? CreateFrom(IBasic_Octets? source)
        {
            if (source is null) return null;
            if (source is Basic_Octets thisEntity) return thisEntity;
            return new Basic_Octets(source);
        }

        private static readonly Basic_Octets _empty = new Basic_Octets();
        public Basic_Octets Empty => _empty;
    }
    public partial record Basic_Octets : EntityBase, IBasic_Octets
    {
        public new const int EntityTag = 31;
        protected override int OnGetEntityTag() => EntityTag;

        public Octets? Scalar { get; init; }
        Octets? IBasic_Octets.Scalar => Scalar;
        public ImmutableList<Octets?>? Vector { get; init; }
        IReadOnlyList<Octets?>? IBasic_Octets.Vector => Vector;
        public ImmutableDictionary<String, Octets?>? MapValue { get; init; }
        IReadOnlyDictionary<String, Octets?>? IBasic_Octets.MapValue => MapValue;
        public ImmutableDictionary<Octets, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Octets, String?>? IBasic_Octets.MapKey => MapKey;

        public Basic_Octets() : base()
        {
        }

        public Basic_Octets(Basic_Octets? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Scalar = source.Scalar;
            Vector = source.Vector;
            MapValue = source.MapValue;
            MapKey = source.MapKey;
        }

        public Basic_Octets(IBasic_Octets? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Scalar = source.Scalar;
            Vector = source.Vector is null
                ? default
                : ImmutableList<Octets?>.Empty.AddRange(source.Vector
                    .Select(x => (Octets?)x));
            MapValue = source.MapValue is null
                ? default
                : ImmutableDictionary<String, Octets?>.Empty.AddRange(source.MapValue
                    .Select(x => new KeyValuePair<String, Octets?>(x.Key, x.Value)));
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Octets, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_Octets? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Scalar.ValueEquals(other.Scalar)) return false;
            if (!Vector.ArrayEquals(other.Vector)) return false;
            if (!MapValue.IndexEquals(other.MapValue)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Scalar.CalcHashUnary());
            hc.Add(Vector.CalcHashArray());
            hc.Add(MapValue.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_Half_Factory : IEntityFactory<IBasic_Half, Basic_Half>
    {
        private static readonly Basic_Half_Factory _instance = new Basic_Half_Factory();
        public static Basic_Half_Factory Instance => _instance;

        public Basic_Half? CreateFrom(IBasic_Half? source)
        {
            if (source is null) return null;
            if (source is Basic_Half thisEntity) return thisEntity;
            return new Basic_Half(source);
        }

        private static readonly Basic_Half _empty = new Basic_Half();
        public Basic_Half Empty => _empty;
    }
    public partial record Basic_Half : EntityBase, IBasic_Half
    {
        public new const int EntityTag = 32;
        protected override int OnGetEntityTag() => EntityTag;

        public Half ScalarRequired { get; init; }
        Half IBasic_Half.ScalarRequired => ScalarRequired;
        public Half? ScalarOptional { get; init; }
        Half? IBasic_Half.ScalarOptional => ScalarOptional;
        public ImmutableList<Half>? VectorRequired { get; init; }
        IReadOnlyList<Half>? IBasic_Half.VectorRequired => VectorRequired;
        public ImmutableList<Half?>? VectorOptional { get; init; }
        IReadOnlyList<Half?>? IBasic_Half.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Half>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Half>? IBasic_Half.MapRequired => MapRequired;
        public ImmutableDictionary<String, Half?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Half?>? IBasic_Half.MapOptional => MapOptional;
        public ImmutableDictionary<Half, String?>? MapKey { get; init; }
        IReadOnlyDictionary<Half, String?>? IBasic_Half.MapKey => MapKey;

        public Basic_Half() : base()
        {
        }

        public Basic_Half(Basic_Half? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_Half(IBasic_Half? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Half>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Half?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Half>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Half?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Half, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_Half? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_DateOnly_Factory : IEntityFactory<IBasic_DateOnly, Basic_DateOnly>
    {
        private static readonly Basic_DateOnly_Factory _instance = new Basic_DateOnly_Factory();
        public static Basic_DateOnly_Factory Instance => _instance;

        public Basic_DateOnly? CreateFrom(IBasic_DateOnly? source)
        {
            if (source is null) return null;
            if (source is Basic_DateOnly thisEntity) return thisEntity;
            return new Basic_DateOnly(source);
        }

        private static readonly Basic_DateOnly _empty = new Basic_DateOnly();
        public Basic_DateOnly Empty => _empty;
    }
    public partial record Basic_DateOnly : EntityBase, IBasic_DateOnly
    {
        public new const int EntityTag = 33;
        protected override int OnGetEntityTag() => EntityTag;

        public DateOnly ScalarRequired { get; init; }
        DateOnly IBasic_DateOnly.ScalarRequired => ScalarRequired;
        public DateOnly? ScalarOptional { get; init; }
        DateOnly? IBasic_DateOnly.ScalarOptional => ScalarOptional;
        public ImmutableList<DateOnly>? VectorRequired { get; init; }
        IReadOnlyList<DateOnly>? IBasic_DateOnly.VectorRequired => VectorRequired;
        public ImmutableList<DateOnly?>? VectorOptional { get; init; }
        IReadOnlyList<DateOnly?>? IBasic_DateOnly.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, DateOnly>? MapRequired { get; init; }
        IReadOnlyDictionary<String, DateOnly>? IBasic_DateOnly.MapRequired => MapRequired;
        public ImmutableDictionary<String, DateOnly?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, DateOnly?>? IBasic_DateOnly.MapOptional => MapOptional;
        public ImmutableDictionary<DateOnly, String?>? MapKey { get; init; }
        IReadOnlyDictionary<DateOnly, String?>? IBasic_DateOnly.MapKey => MapKey;

        public Basic_DateOnly() : base()
        {
        }

        public Basic_DateOnly(Basic_DateOnly? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_DateOnly(IBasic_DateOnly? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<DateOnly>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<DateOnly?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, DateOnly>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, DateOnly?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<DateOnly, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_DateOnly? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_TimeOnly_Factory : IEntityFactory<IBasic_TimeOnly, Basic_TimeOnly>
    {
        private static readonly Basic_TimeOnly_Factory _instance = new Basic_TimeOnly_Factory();
        public static Basic_TimeOnly_Factory Instance => _instance;

        public Basic_TimeOnly? CreateFrom(IBasic_TimeOnly? source)
        {
            if (source is null) return null;
            if (source is Basic_TimeOnly thisEntity) return thisEntity;
            return new Basic_TimeOnly(source);
        }

        private static readonly Basic_TimeOnly _empty = new Basic_TimeOnly();
        public Basic_TimeOnly Empty => _empty;
    }
    public partial record Basic_TimeOnly : EntityBase, IBasic_TimeOnly
    {
        public new const int EntityTag = 34;
        protected override int OnGetEntityTag() => EntityTag;

        public TimeOnly ScalarRequired { get; init; }
        TimeOnly IBasic_TimeOnly.ScalarRequired => ScalarRequired;
        public TimeOnly? ScalarOptional { get; init; }
        TimeOnly? IBasic_TimeOnly.ScalarOptional => ScalarOptional;
        public ImmutableList<TimeOnly>? VectorRequired { get; init; }
        IReadOnlyList<TimeOnly>? IBasic_TimeOnly.VectorRequired => VectorRequired;
        public ImmutableList<TimeOnly?>? VectorOptional { get; init; }
        IReadOnlyList<TimeOnly?>? IBasic_TimeOnly.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, TimeOnly>? MapRequired { get; init; }
        IReadOnlyDictionary<String, TimeOnly>? IBasic_TimeOnly.MapRequired => MapRequired;
        public ImmutableDictionary<String, TimeOnly?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, TimeOnly?>? IBasic_TimeOnly.MapOptional => MapOptional;
        public ImmutableDictionary<TimeOnly, String?>? MapKey { get; init; }
        IReadOnlyDictionary<TimeOnly, String?>? IBasic_TimeOnly.MapKey => MapKey;

        public Basic_TimeOnly() : base()
        {
        }

        public Basic_TimeOnly(Basic_TimeOnly? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
            MapKey = source.MapKey;
        }

        public Basic_TimeOnly(IBasic_TimeOnly? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<TimeOnly>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<TimeOnly?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, TimeOnly>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, TimeOnly?>.Empty.AddRange(source.MapOptional);
            MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<TimeOnly, String?>.Empty.AddRange(source.MapKey);
        }

        public virtual bool Equals(Basic_TimeOnly? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_Complex_Factory : IEntityFactory<IBasic_Complex, Basic_Complex>
    {
        private static readonly Basic_Complex_Factory _instance = new Basic_Complex_Factory();
        public static Basic_Complex_Factory Instance => _instance;

        public Basic_Complex? CreateFrom(IBasic_Complex? source)
        {
            if (source is null) return null;
            if (source is Basic_Complex thisEntity) return thisEntity;
            return new Basic_Complex(source);
        }

        private static readonly Basic_Complex _empty = new Basic_Complex();
        public Basic_Complex Empty => _empty;
    }
    public partial record Basic_Complex : EntityBase, IBasic_Complex
    {
        public new const int EntityTag = 35;
        protected override int OnGetEntityTag() => EntityTag;

        public Complex ScalarRequired { get; init; }
        Complex IBasic_Complex.ScalarRequired => ScalarRequired;
        public Complex? ScalarOptional { get; init; }
        Complex? IBasic_Complex.ScalarOptional => ScalarOptional;
        public ImmutableList<Complex>? VectorRequired { get; init; }
        IReadOnlyList<Complex>? IBasic_Complex.VectorRequired => VectorRequired;
        public ImmutableList<Complex?>? VectorOptional { get; init; }
        IReadOnlyList<Complex?>? IBasic_Complex.VectorOptional => VectorOptional;
        public ImmutableDictionary<String, Complex>? MapRequired { get; init; }
        IReadOnlyDictionary<String, Complex>? IBasic_Complex.MapRequired => MapRequired;
        public ImmutableDictionary<String, Complex?>? MapOptional { get; init; }
        IReadOnlyDictionary<String, Complex?>? IBasic_Complex.MapOptional => MapOptional;

        public Basic_Complex() : base()
        {
        }

        public Basic_Complex(Basic_Complex? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired;
            VectorOptional = source.VectorOptional;
            MapRequired = source.MapRequired;
            MapOptional = source.MapOptional;
        }

        public Basic_Complex(IBasic_Complex? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            ScalarRequired = source.ScalarRequired;
            ScalarOptional = source.ScalarOptional;
            VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Complex>.Empty.AddRange(source.VectorRequired);
            VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Complex?>.Empty.AddRange(source.VectorOptional);
            MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Complex>.Empty.AddRange(source.MapRequired);
            MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Complex?>.Empty.AddRange(source.MapOptional);
        }

        public virtual bool Equals(Basic_Complex? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!ScalarRequired.ValueEquals(other.ScalarRequired)) return false;
            if (!ScalarOptional.ValueEquals(other.ScalarOptional)) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }

    public sealed class Basic_Version_Factory : IEntityFactory<IBasic_Version, Basic_Version>
    {
        private static readonly Basic_Version_Factory _instance = new Basic_Version_Factory();
        public static Basic_Version_Factory Instance => _instance;

        public Basic_Version? CreateFrom(IBasic_Version? source)
        {
            if (source is null) return null;
            if (source is Basic_Version thisEntity) return thisEntity;
            return new Basic_Version(source);
        }

        private static readonly Basic_Version _empty = new Basic_Version();
        public Basic_Version Empty => _empty;
    }
    public partial record Basic_Version : EntityBase, IBasic_Version
    {
        public new const int EntityTag = 36;
        protected override int OnGetEntityTag() => EntityTag;

        public Version? Scalar { get; init; }
        Version? IBasic_Version.Scalar => Scalar;
        public ImmutableList<Version?>? Vector { get; init; }
        IReadOnlyList<Version?>? IBasic_Version.Vector => Vector;
        public ImmutableDictionary<String, Version?>? MapValue { get; init; }
        IReadOnlyDictionary<String, Version?>? IBasic_Version.MapValue => MapValue;

        public Basic_Version() : base()
        {
        }

        public Basic_Version(Basic_Version? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Scalar = source.Scalar;
            Vector = source.Vector;
            MapValue = source.MapValue;
        }

        public Basic_Version(IBasic_Version? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            Scalar = source.Scalar;
            Vector = source.Vector is null
                ? default
                : ImmutableList<Version?>.Empty.AddRange(source.Vector);
            MapValue = source.MapValue is null
                ? default
                : ImmutableDictionary<String, Version?>.Empty.AddRange(source.MapValue);
        }

        public virtual bool Equals(Basic_Version? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!Scalar.ValueEquals(other.Scalar)) return false;
            if (!Vector.ArrayEquals(other.Vector)) return false;
            if (!MapValue.IndexEquals(other.MapValue)) return false;
            return base.Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(Scalar.CalcHashUnary());
            hc.Add(Vector.CalcHashArray());
            hc.Add(MapValue.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }
    }



}

#region Notices
// <auto-generated>
// Warning: This file was automatically generated. Changes to this file may
// cause incorrect behavior and will be lost when this file is regenerated.
// </auto-generated>
// <information>
// This file was generated using MetaFac.CG4 tools and user supplied metadata.
// Generator: JsonNewtonSoft.2.1
// Metadata : MetaFac.CG4.TestOrg.Schema(.BasicTypes)
// </information>
#endregion
#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable CS8019 // Unnecessary using directive
using MetaFac.Mutability;
using MetaFac.CG4.Runtime;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Runtime.CompilerServices;
using MetaFac.CG4.TestOrg.Models.BasicTypes.Contracts;
using MetaFac.Memory;

namespace MetaFac.CG4.TestOrg.Models.BasicTypes.JsonNewtonSoft
{


    public abstract class EntityBase : IFreezable, IEntityBase
    {
        public static EntityBase Empty => throw new NotSupportedException();
        public const int EntityTag = 0;
        public EntityBase() { }
        public EntityBase(EntityBase? source) { }
        public EntityBase(IEntityBase? source) { }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IEntityBase? source) { }
        protected abstract int OnGetEntityTag();
        public int GetEntityTag() => OnGetEntityTag();
        public bool Equals(EntityBase? other) => true;
        public override int GetHashCode() => 0;

        public bool IsFreezable() => false;
        public bool IsFrozen() => false;
        public void Freeze() { }
        public bool TryFreeze() => true;
    }


    public partial class Basic_bool
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_bool? CreateFrom(IBasic_bool? source)
        {
            if (source is null) return null;
            return new Basic_bool(source);
        }

        private static Basic_bool CreateEmpty()
        {
            var empty = new Basic_bool();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_bool _empty = CreateEmpty();
        public static new Basic_bool Empty => _empty;

    }
    public partial class Basic_bool : EntityBase, IBasic_bool, IEquatable<Basic_bool>
    {
        public new const int EntityTag = 1;
        protected override int OnGetEntityTag() => EntityTag;

        private Boolean field_ScalarRequired;
        Boolean IBasic_bool.ScalarRequired => field_ScalarRequired;
        public Boolean ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private Boolean? field_ScalarOptional;
        Boolean? IBasic_bool.ScalarOptional => field_ScalarOptional;
        public Boolean? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<Boolean>? field_VectorRequired;
        IReadOnlyList<Boolean>? IBasic_bool.VectorRequired => field_VectorRequired;
        public ImmutableList<Boolean>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<Boolean?>? field_VectorOptional;
        IReadOnlyList<Boolean?>? IBasic_bool.VectorOptional => field_VectorOptional;
        public ImmutableList<Boolean?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, Boolean>? field_MapRequired;
        IReadOnlyDictionary<String, Boolean>? IBasic_bool.MapRequired => MapRequired;
        public ImmutableDictionary<String, Boolean>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, Boolean?>? field_MapOptional;
        IReadOnlyDictionary<String, Boolean?>? IBasic_bool.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, Boolean?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<Boolean, String?>? field_MapKey;
        IReadOnlyDictionary<Boolean, String?>? IBasic_bool.MapKey => field_MapKey;
        public ImmutableDictionary<Boolean, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_bool() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_bool(Basic_bool? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_bool(IBasic_bool? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Boolean>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Boolean?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Boolean>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Boolean?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Boolean, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_bool? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Boolean>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Boolean?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Boolean>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Boolean?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Boolean, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_bool? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_bool other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_sbyte
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_sbyte? CreateFrom(IBasic_sbyte? source)
        {
            if (source is null) return null;
            return new Basic_sbyte(source);
        }

        private static Basic_sbyte CreateEmpty()
        {
            var empty = new Basic_sbyte();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_sbyte _empty = CreateEmpty();
        public static new Basic_sbyte Empty => _empty;

    }
    public partial class Basic_sbyte : EntityBase, IBasic_sbyte, IEquatable<Basic_sbyte>
    {
        public new const int EntityTag = 2;
        protected override int OnGetEntityTag() => EntityTag;

        private SByte field_ScalarRequired;
        SByte IBasic_sbyte.ScalarRequired => field_ScalarRequired;
        public SByte ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private SByte? field_ScalarOptional;
        SByte? IBasic_sbyte.ScalarOptional => field_ScalarOptional;
        public SByte? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<SByte>? field_VectorRequired;
        IReadOnlyList<SByte>? IBasic_sbyte.VectorRequired => field_VectorRequired;
        public ImmutableList<SByte>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<SByte?>? field_VectorOptional;
        IReadOnlyList<SByte?>? IBasic_sbyte.VectorOptional => field_VectorOptional;
        public ImmutableList<SByte?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, SByte>? field_MapRequired;
        IReadOnlyDictionary<String, SByte>? IBasic_sbyte.MapRequired => MapRequired;
        public ImmutableDictionary<String, SByte>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, SByte?>? field_MapOptional;
        IReadOnlyDictionary<String, SByte?>? IBasic_sbyte.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, SByte?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<SByte, String?>? field_MapKey;
        IReadOnlyDictionary<SByte, String?>? IBasic_sbyte.MapKey => field_MapKey;
        public ImmutableDictionary<SByte, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_sbyte() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_sbyte(Basic_sbyte? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_sbyte(IBasic_sbyte? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<SByte>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<SByte?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, SByte>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, SByte?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<SByte, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_sbyte? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<SByte>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<SByte?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, SByte>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, SByte?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<SByte, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_sbyte? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_sbyte other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_byte
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_byte? CreateFrom(IBasic_byte? source)
        {
            if (source is null) return null;
            return new Basic_byte(source);
        }

        private static Basic_byte CreateEmpty()
        {
            var empty = new Basic_byte();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_byte _empty = CreateEmpty();
        public static new Basic_byte Empty => _empty;

    }
    public partial class Basic_byte : EntityBase, IBasic_byte, IEquatable<Basic_byte>
    {
        public new const int EntityTag = 3;
        protected override int OnGetEntityTag() => EntityTag;

        private Byte field_ScalarRequired;
        Byte IBasic_byte.ScalarRequired => field_ScalarRequired;
        public Byte ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private Byte? field_ScalarOptional;
        Byte? IBasic_byte.ScalarOptional => field_ScalarOptional;
        public Byte? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<Byte>? field_VectorRequired;
        IReadOnlyList<Byte>? IBasic_byte.VectorRequired => field_VectorRequired;
        public ImmutableList<Byte>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<Byte?>? field_VectorOptional;
        IReadOnlyList<Byte?>? IBasic_byte.VectorOptional => field_VectorOptional;
        public ImmutableList<Byte?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, Byte>? field_MapRequired;
        IReadOnlyDictionary<String, Byte>? IBasic_byte.MapRequired => MapRequired;
        public ImmutableDictionary<String, Byte>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, Byte?>? field_MapOptional;
        IReadOnlyDictionary<String, Byte?>? IBasic_byte.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, Byte?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<Byte, String?>? field_MapKey;
        IReadOnlyDictionary<Byte, String?>? IBasic_byte.MapKey => field_MapKey;
        public ImmutableDictionary<Byte, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_byte() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_byte(Basic_byte? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_byte(IBasic_byte? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Byte>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Byte?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Byte>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Byte?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Byte, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_byte? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Byte>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Byte?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Byte>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Byte?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Byte, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_byte? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_byte other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_short
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_short? CreateFrom(IBasic_short? source)
        {
            if (source is null) return null;
            return new Basic_short(source);
        }

        private static Basic_short CreateEmpty()
        {
            var empty = new Basic_short();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_short _empty = CreateEmpty();
        public static new Basic_short Empty => _empty;

    }
    public partial class Basic_short : EntityBase, IBasic_short, IEquatable<Basic_short>
    {
        public new const int EntityTag = 4;
        protected override int OnGetEntityTag() => EntityTag;

        private Int16 field_ScalarRequired;
        Int16 IBasic_short.ScalarRequired => field_ScalarRequired;
        public Int16 ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private Int16? field_ScalarOptional;
        Int16? IBasic_short.ScalarOptional => field_ScalarOptional;
        public Int16? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<Int16>? field_VectorRequired;
        IReadOnlyList<Int16>? IBasic_short.VectorRequired => field_VectorRequired;
        public ImmutableList<Int16>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<Int16?>? field_VectorOptional;
        IReadOnlyList<Int16?>? IBasic_short.VectorOptional => field_VectorOptional;
        public ImmutableList<Int16?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, Int16>? field_MapRequired;
        IReadOnlyDictionary<String, Int16>? IBasic_short.MapRequired => MapRequired;
        public ImmutableDictionary<String, Int16>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, Int16?>? field_MapOptional;
        IReadOnlyDictionary<String, Int16?>? IBasic_short.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, Int16?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<Int16, String?>? field_MapKey;
        IReadOnlyDictionary<Int16, String?>? IBasic_short.MapKey => field_MapKey;
        public ImmutableDictionary<Int16, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_short() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_short(Basic_short? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_short(IBasic_short? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Int16>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Int16?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Int16>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Int16?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Int16, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_short? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Int16>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Int16?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Int16>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Int16?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Int16, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_short? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_short other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_ushort
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_ushort? CreateFrom(IBasic_ushort? source)
        {
            if (source is null) return null;
            return new Basic_ushort(source);
        }

        private static Basic_ushort CreateEmpty()
        {
            var empty = new Basic_ushort();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_ushort _empty = CreateEmpty();
        public static new Basic_ushort Empty => _empty;

    }
    public partial class Basic_ushort : EntityBase, IBasic_ushort, IEquatable<Basic_ushort>
    {
        public new const int EntityTag = 5;
        protected override int OnGetEntityTag() => EntityTag;

        private UInt16 field_ScalarRequired;
        UInt16 IBasic_ushort.ScalarRequired => field_ScalarRequired;
        public UInt16 ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private UInt16? field_ScalarOptional;
        UInt16? IBasic_ushort.ScalarOptional => field_ScalarOptional;
        public UInt16? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<UInt16>? field_VectorRequired;
        IReadOnlyList<UInt16>? IBasic_ushort.VectorRequired => field_VectorRequired;
        public ImmutableList<UInt16>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<UInt16?>? field_VectorOptional;
        IReadOnlyList<UInt16?>? IBasic_ushort.VectorOptional => field_VectorOptional;
        public ImmutableList<UInt16?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, UInt16>? field_MapRequired;
        IReadOnlyDictionary<String, UInt16>? IBasic_ushort.MapRequired => MapRequired;
        public ImmutableDictionary<String, UInt16>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, UInt16?>? field_MapOptional;
        IReadOnlyDictionary<String, UInt16?>? IBasic_ushort.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, UInt16?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<UInt16, String?>? field_MapKey;
        IReadOnlyDictionary<UInt16, String?>? IBasic_ushort.MapKey => field_MapKey;
        public ImmutableDictionary<UInt16, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_ushort() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_ushort(Basic_ushort? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_ushort(IBasic_ushort? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<UInt16>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<UInt16?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, UInt16>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, UInt16?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<UInt16, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_ushort? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<UInt16>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<UInt16?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, UInt16>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, UInt16?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<UInt16, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_ushort? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_ushort other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_char
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_char? CreateFrom(IBasic_char? source)
        {
            if (source is null) return null;
            return new Basic_char(source);
        }

        private static Basic_char CreateEmpty()
        {
            var empty = new Basic_char();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_char _empty = CreateEmpty();
        public static new Basic_char Empty => _empty;

    }
    public partial class Basic_char : EntityBase, IBasic_char, IEquatable<Basic_char>
    {
        public new const int EntityTag = 6;
        protected override int OnGetEntityTag() => EntityTag;

        private Char field_ScalarRequired;
        Char IBasic_char.ScalarRequired => field_ScalarRequired;
        public Char ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private Char? field_ScalarOptional;
        Char? IBasic_char.ScalarOptional => field_ScalarOptional;
        public Char? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<Char>? field_VectorRequired;
        IReadOnlyList<Char>? IBasic_char.VectorRequired => field_VectorRequired;
        public ImmutableList<Char>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<Char?>? field_VectorOptional;
        IReadOnlyList<Char?>? IBasic_char.VectorOptional => field_VectorOptional;
        public ImmutableList<Char?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, Char>? field_MapRequired;
        IReadOnlyDictionary<String, Char>? IBasic_char.MapRequired => MapRequired;
        public ImmutableDictionary<String, Char>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, Char?>? field_MapOptional;
        IReadOnlyDictionary<String, Char?>? IBasic_char.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, Char?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<Char, String?>? field_MapKey;
        IReadOnlyDictionary<Char, String?>? IBasic_char.MapKey => field_MapKey;
        public ImmutableDictionary<Char, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_char() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_char(Basic_char? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_char(IBasic_char? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Char>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Char?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Char>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Char?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Char, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_char? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Char>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Char?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Char>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Char?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Char, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_char? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_char other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_int
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_int? CreateFrom(IBasic_int? source)
        {
            if (source is null) return null;
            return new Basic_int(source);
        }

        private static Basic_int CreateEmpty()
        {
            var empty = new Basic_int();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_int _empty = CreateEmpty();
        public static new Basic_int Empty => _empty;

    }
    public partial class Basic_int : EntityBase, IBasic_int, IEquatable<Basic_int>
    {
        public new const int EntityTag = 7;
        protected override int OnGetEntityTag() => EntityTag;

        private Int32 field_ScalarRequired;
        Int32 IBasic_int.ScalarRequired => field_ScalarRequired;
        public Int32 ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private Int32? field_ScalarOptional;
        Int32? IBasic_int.ScalarOptional => field_ScalarOptional;
        public Int32? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<Int32>? field_VectorRequired;
        IReadOnlyList<Int32>? IBasic_int.VectorRequired => field_VectorRequired;
        public ImmutableList<Int32>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<Int32?>? field_VectorOptional;
        IReadOnlyList<Int32?>? IBasic_int.VectorOptional => field_VectorOptional;
        public ImmutableList<Int32?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, Int32>? field_MapRequired;
        IReadOnlyDictionary<String, Int32>? IBasic_int.MapRequired => MapRequired;
        public ImmutableDictionary<String, Int32>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, Int32?>? field_MapOptional;
        IReadOnlyDictionary<String, Int32?>? IBasic_int.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, Int32?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<Int32, String?>? field_MapKey;
        IReadOnlyDictionary<Int32, String?>? IBasic_int.MapKey => field_MapKey;
        public ImmutableDictionary<Int32, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_int() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_int(Basic_int? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_int(IBasic_int? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Int32>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Int32?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Int32>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Int32?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Int32, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_int? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Int32>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Int32?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Int32>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Int32?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Int32, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_int? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_int other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_uint
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_uint? CreateFrom(IBasic_uint? source)
        {
            if (source is null) return null;
            return new Basic_uint(source);
        }

        private static Basic_uint CreateEmpty()
        {
            var empty = new Basic_uint();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_uint _empty = CreateEmpty();
        public static new Basic_uint Empty => _empty;

    }
    public partial class Basic_uint : EntityBase, IBasic_uint, IEquatable<Basic_uint>
    {
        public new const int EntityTag = 8;
        protected override int OnGetEntityTag() => EntityTag;

        private UInt32 field_ScalarRequired;
        UInt32 IBasic_uint.ScalarRequired => field_ScalarRequired;
        public UInt32 ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private UInt32? field_ScalarOptional;
        UInt32? IBasic_uint.ScalarOptional => field_ScalarOptional;
        public UInt32? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<UInt32>? field_VectorRequired;
        IReadOnlyList<UInt32>? IBasic_uint.VectorRequired => field_VectorRequired;
        public ImmutableList<UInt32>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<UInt32?>? field_VectorOptional;
        IReadOnlyList<UInt32?>? IBasic_uint.VectorOptional => field_VectorOptional;
        public ImmutableList<UInt32?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, UInt32>? field_MapRequired;
        IReadOnlyDictionary<String, UInt32>? IBasic_uint.MapRequired => MapRequired;
        public ImmutableDictionary<String, UInt32>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, UInt32?>? field_MapOptional;
        IReadOnlyDictionary<String, UInt32?>? IBasic_uint.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, UInt32?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<UInt32, String?>? field_MapKey;
        IReadOnlyDictionary<UInt32, String?>? IBasic_uint.MapKey => field_MapKey;
        public ImmutableDictionary<UInt32, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_uint() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_uint(Basic_uint? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_uint(IBasic_uint? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<UInt32>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<UInt32?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, UInt32>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, UInt32?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<UInt32, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_uint? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<UInt32>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<UInt32?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, UInt32>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, UInt32?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<UInt32, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_uint? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_uint other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_float
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_float? CreateFrom(IBasic_float? source)
        {
            if (source is null) return null;
            return new Basic_float(source);
        }

        private static Basic_float CreateEmpty()
        {
            var empty = new Basic_float();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_float _empty = CreateEmpty();
        public static new Basic_float Empty => _empty;

    }
    public partial class Basic_float : EntityBase, IBasic_float, IEquatable<Basic_float>
    {
        public new const int EntityTag = 9;
        protected override int OnGetEntityTag() => EntityTag;

        private Single field_ScalarRequired;
        Single IBasic_float.ScalarRequired => field_ScalarRequired;
        public Single ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private Single? field_ScalarOptional;
        Single? IBasic_float.ScalarOptional => field_ScalarOptional;
        public Single? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<Single>? field_VectorRequired;
        IReadOnlyList<Single>? IBasic_float.VectorRequired => field_VectorRequired;
        public ImmutableList<Single>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<Single?>? field_VectorOptional;
        IReadOnlyList<Single?>? IBasic_float.VectorOptional => field_VectorOptional;
        public ImmutableList<Single?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, Single>? field_MapRequired;
        IReadOnlyDictionary<String, Single>? IBasic_float.MapRequired => MapRequired;
        public ImmutableDictionary<String, Single>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, Single?>? field_MapOptional;
        IReadOnlyDictionary<String, Single?>? IBasic_float.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, Single?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<Single, String?>? field_MapKey;
        IReadOnlyDictionary<Single, String?>? IBasic_float.MapKey => field_MapKey;
        public ImmutableDictionary<Single, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_float() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_float(Basic_float? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_float(IBasic_float? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Single>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Single?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Single>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Single?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Single, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_float? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Single>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Single?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Single>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Single?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Single, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_float? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_float other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_decimal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_decimal? CreateFrom(IBasic_decimal? source)
        {
            if (source is null) return null;
            return new Basic_decimal(source);
        }

        private static Basic_decimal CreateEmpty()
        {
            var empty = new Basic_decimal();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_decimal _empty = CreateEmpty();
        public static new Basic_decimal Empty => _empty;

    }
    public partial class Basic_decimal : EntityBase, IBasic_decimal, IEquatable<Basic_decimal>
    {
        public new const int EntityTag = 17;
        protected override int OnGetEntityTag() => EntityTag;

        private Decimal field_ScalarRequired;
        Decimal IBasic_decimal.ScalarRequired => field_ScalarRequired;
        public Decimal ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private Decimal? field_ScalarOptional;
        Decimal? IBasic_decimal.ScalarOptional => field_ScalarOptional;
        public Decimal? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<Decimal>? field_VectorRequired;
        IReadOnlyList<Decimal>? IBasic_decimal.VectorRequired => field_VectorRequired;
        public ImmutableList<Decimal>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<Decimal?>? field_VectorOptional;
        IReadOnlyList<Decimal?>? IBasic_decimal.VectorOptional => field_VectorOptional;
        public ImmutableList<Decimal?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, Decimal>? field_MapRequired;
        IReadOnlyDictionary<String, Decimal>? IBasic_decimal.MapRequired => MapRequired;
        public ImmutableDictionary<String, Decimal>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, Decimal?>? field_MapOptional;
        IReadOnlyDictionary<String, Decimal?>? IBasic_decimal.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, Decimal?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<Decimal, String?>? field_MapKey;
        IReadOnlyDictionary<Decimal, String?>? IBasic_decimal.MapKey => field_MapKey;
        public ImmutableDictionary<Decimal, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_decimal() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_decimal(Basic_decimal? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_decimal(IBasic_decimal? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Decimal>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Decimal?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Decimal>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Decimal?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Decimal, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_decimal? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Decimal>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Decimal?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Decimal>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Decimal?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Decimal, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_decimal? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_decimal other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_DateTimeOffset
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_DateTimeOffset? CreateFrom(IBasic_DateTimeOffset? source)
        {
            if (source is null) return null;
            return new Basic_DateTimeOffset(source);
        }

        private static Basic_DateTimeOffset CreateEmpty()
        {
            var empty = new Basic_DateTimeOffset();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_DateTimeOffset _empty = CreateEmpty();
        public static new Basic_DateTimeOffset Empty => _empty;

    }
    public partial class Basic_DateTimeOffset : EntityBase, IBasic_DateTimeOffset, IEquatable<Basic_DateTimeOffset>
    {
        public new const int EntityTag = 18;
        protected override int OnGetEntityTag() => EntityTag;

        private DateTimeOffset field_ScalarRequired;
        DateTimeOffset IBasic_DateTimeOffset.ScalarRequired => field_ScalarRequired;
        public DateTimeOffset ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private DateTimeOffset? field_ScalarOptional;
        DateTimeOffset? IBasic_DateTimeOffset.ScalarOptional => field_ScalarOptional;
        public DateTimeOffset? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<DateTimeOffset>? field_VectorRequired;
        IReadOnlyList<DateTimeOffset>? IBasic_DateTimeOffset.VectorRequired => field_VectorRequired;
        public ImmutableList<DateTimeOffset>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<DateTimeOffset?>? field_VectorOptional;
        IReadOnlyList<DateTimeOffset?>? IBasic_DateTimeOffset.VectorOptional => field_VectorOptional;
        public ImmutableList<DateTimeOffset?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, DateTimeOffset>? field_MapRequired;
        IReadOnlyDictionary<String, DateTimeOffset>? IBasic_DateTimeOffset.MapRequired => MapRequired;
        public ImmutableDictionary<String, DateTimeOffset>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, DateTimeOffset?>? field_MapOptional;
        IReadOnlyDictionary<String, DateTimeOffset?>? IBasic_DateTimeOffset.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, DateTimeOffset?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<DateTimeOffset, String?>? field_MapKey;
        IReadOnlyDictionary<DateTimeOffset, String?>? IBasic_DateTimeOffset.MapKey => field_MapKey;
        public ImmutableDictionary<DateTimeOffset, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DateTimeOffset() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DateTimeOffset(Basic_DateTimeOffset? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DateTimeOffset(IBasic_DateTimeOffset? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<DateTimeOffset>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<DateTimeOffset?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, DateTimeOffset>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, DateTimeOffset?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<DateTimeOffset, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_DateTimeOffset? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<DateTimeOffset>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<DateTimeOffset?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, DateTimeOffset>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, DateTimeOffset?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<DateTimeOffset, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_DateTimeOffset? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_DateTimeOffset other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_Guid
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_Guid? CreateFrom(IBasic_Guid? source)
        {
            if (source is null) return null;
            return new Basic_Guid(source);
        }

        private static Basic_Guid CreateEmpty()
        {
            var empty = new Basic_Guid();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_Guid _empty = CreateEmpty();
        public static new Basic_Guid Empty => _empty;

    }
    public partial class Basic_Guid : EntityBase, IBasic_Guid, IEquatable<Basic_Guid>
    {
        public new const int EntityTag = 19;
        protected override int OnGetEntityTag() => EntityTag;

        private Guid field_ScalarRequired;
        Guid IBasic_Guid.ScalarRequired => field_ScalarRequired;
        public Guid ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private Guid? field_ScalarOptional;
        Guid? IBasic_Guid.ScalarOptional => field_ScalarOptional;
        public Guid? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<Guid>? field_VectorRequired;
        IReadOnlyList<Guid>? IBasic_Guid.VectorRequired => field_VectorRequired;
        public ImmutableList<Guid>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<Guid?>? field_VectorOptional;
        IReadOnlyList<Guid?>? IBasic_Guid.VectorOptional => field_VectorOptional;
        public ImmutableList<Guid?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, Guid>? field_MapRequired;
        IReadOnlyDictionary<String, Guid>? IBasic_Guid.MapRequired => MapRequired;
        public ImmutableDictionary<String, Guid>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, Guid?>? field_MapOptional;
        IReadOnlyDictionary<String, Guid?>? IBasic_Guid.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, Guid?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<Guid, String?>? field_MapKey;
        IReadOnlyDictionary<Guid, String?>? IBasic_Guid.MapKey => field_MapKey;
        public ImmutableDictionary<Guid, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Guid() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Guid(Basic_Guid? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Guid(IBasic_Guid? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Guid>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Guid?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Guid>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Guid?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Guid, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_Guid? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<Guid>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<Guid?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, Guid>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, Guid?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<Guid, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_Guid? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_Guid other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_DayOfWeek
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_DayOfWeek? CreateFrom(IBasic_DayOfWeek? source)
        {
            if (source is null) return null;
            return new Basic_DayOfWeek(source);
        }

        private static Basic_DayOfWeek CreateEmpty()
        {
            var empty = new Basic_DayOfWeek();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_DayOfWeek _empty = CreateEmpty();
        public static new Basic_DayOfWeek Empty => _empty;

    }
    public partial class Basic_DayOfWeek : EntityBase, IBasic_DayOfWeek, IEquatable<Basic_DayOfWeek>
    {
        public new const int EntityTag = 20;
        protected override int OnGetEntityTag() => EntityTag;

        private System.DayOfWeek field_ScalarRequired;
        System.DayOfWeek IBasic_DayOfWeek.ScalarRequired => field_ScalarRequired;
        public System.DayOfWeek ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private System.DayOfWeek? field_ScalarOptional;
        System.DayOfWeek? IBasic_DayOfWeek.ScalarOptional => field_ScalarOptional;
        public System.DayOfWeek? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<System.DayOfWeek>? field_VectorRequired;
        IReadOnlyList<System.DayOfWeek>? IBasic_DayOfWeek.VectorRequired => field_VectorRequired;
        public ImmutableList<System.DayOfWeek>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<System.DayOfWeek?>? field_VectorOptional;
        IReadOnlyList<System.DayOfWeek?>? IBasic_DayOfWeek.VectorOptional => field_VectorOptional;
        public ImmutableList<System.DayOfWeek?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, System.DayOfWeek>? field_MapRequired;
        IReadOnlyDictionary<String, System.DayOfWeek>? IBasic_DayOfWeek.MapRequired => MapRequired;
        public ImmutableDictionary<String, System.DayOfWeek>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, System.DayOfWeek?>? field_MapOptional;
        IReadOnlyDictionary<String, System.DayOfWeek?>? IBasic_DayOfWeek.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, System.DayOfWeek?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<System.DayOfWeek, String?>? field_MapKey;
        IReadOnlyDictionary<System.DayOfWeek, String?>? IBasic_DayOfWeek.MapKey => field_MapKey;
        public ImmutableDictionary<System.DayOfWeek, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DayOfWeek() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DayOfWeek(Basic_DayOfWeek? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DayOfWeek(IBasic_DayOfWeek? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<System.DayOfWeek>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<System.DayOfWeek?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, System.DayOfWeek>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, System.DayOfWeek?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<System.DayOfWeek, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_DayOfWeek? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<System.DayOfWeek>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<System.DayOfWeek?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, System.DayOfWeek>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, System.DayOfWeek?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<System.DayOfWeek, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_DayOfWeek? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_DayOfWeek other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_MyCustomEnum
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_MyCustomEnum? CreateFrom(IBasic_MyCustomEnum? source)
        {
            if (source is null) return null;
            return new Basic_MyCustomEnum(source);
        }

        private static Basic_MyCustomEnum CreateEmpty()
        {
            var empty = new Basic_MyCustomEnum();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_MyCustomEnum _empty = CreateEmpty();
        public static new Basic_MyCustomEnum Empty => _empty;

    }
    public partial class Basic_MyCustomEnum : EntityBase, IBasic_MyCustomEnum, IEquatable<Basic_MyCustomEnum>
    {
        public new const int EntityTag = 21;
        protected override int OnGetEntityTag() => EntityTag;

        private MyCustomEnum field_ScalarRequired;
        MyCustomEnum IBasic_MyCustomEnum.ScalarRequired => field_ScalarRequired;
        public MyCustomEnum ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private MyCustomEnum? field_ScalarOptional;
        MyCustomEnum? IBasic_MyCustomEnum.ScalarOptional => field_ScalarOptional;
        public MyCustomEnum? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<MyCustomEnum>? field_VectorRequired;
        IReadOnlyList<MyCustomEnum>? IBasic_MyCustomEnum.VectorRequired => field_VectorRequired;
        public ImmutableList<MyCustomEnum>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<MyCustomEnum?>? field_VectorOptional;
        IReadOnlyList<MyCustomEnum?>? IBasic_MyCustomEnum.VectorOptional => field_VectorOptional;
        public ImmutableList<MyCustomEnum?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, MyCustomEnum>? field_MapRequired;
        IReadOnlyDictionary<String, MyCustomEnum>? IBasic_MyCustomEnum.MapRequired => MapRequired;
        public ImmutableDictionary<String, MyCustomEnum>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, MyCustomEnum?>? field_MapOptional;
        IReadOnlyDictionary<String, MyCustomEnum?>? IBasic_MyCustomEnum.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, MyCustomEnum?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }
        private ImmutableDictionary<MyCustomEnum, String?>? field_MapKey;
        IReadOnlyDictionary<MyCustomEnum, String?>? IBasic_MyCustomEnum.MapKey => field_MapKey;
        public ImmutableDictionary<MyCustomEnum, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_MyCustomEnum() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_MyCustomEnum(Basic_MyCustomEnum? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
            field_MapKey = source.MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_MyCustomEnum(IBasic_MyCustomEnum? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<MyCustomEnum>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<MyCustomEnum?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, MyCustomEnum>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, MyCustomEnum?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<MyCustomEnum, String?>.Empty.AddRange(source.MapKey);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_MyCustomEnum? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<MyCustomEnum>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<MyCustomEnum?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, MyCustomEnum>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, MyCustomEnum?>.Empty.AddRange(source.MapOptional);
            field_MapKey = source.MapKey is null
                ? default
                : ImmutableDictionary<MyCustomEnum, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_MyCustomEnum? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            if (!MapKey.IndexEquals(other.MapKey)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_MyCustomEnum other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            hc.Add(MapKey.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_Quantity
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_Quantity? CreateFrom(IBasic_Quantity? source)
        {
            if (source is null) return null;
            return new Basic_Quantity(source);
        }

        private static Basic_Quantity CreateEmpty()
        {
            var empty = new Basic_Quantity();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_Quantity _empty = CreateEmpty();
        public static new Basic_Quantity Empty => _empty;

    }
    public partial class Basic_Quantity : EntityBase, IBasic_Quantity, IEquatable<Basic_Quantity>
    {
        public new const int EntityTag = 22;
        protected override int OnGetEntityTag() => EntityTag;

        private LabApps.Units.Quantity field_ScalarRequired;
        LabApps.Units.Quantity IBasic_Quantity.ScalarRequired => field_ScalarRequired;
        public LabApps.Units.Quantity ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = value;
        }
        private LabApps.Units.Quantity? field_ScalarOptional;
        LabApps.Units.Quantity? IBasic_Quantity.ScalarOptional => field_ScalarOptional;
        public LabApps.Units.Quantity? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = value;
        }
        private ImmutableList<LabApps.Units.Quantity>? field_VectorRequired;
        IReadOnlyList<LabApps.Units.Quantity>? IBasic_Quantity.VectorRequired => field_VectorRequired;
        public ImmutableList<LabApps.Units.Quantity>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = value;
        }
        private ImmutableList<LabApps.Units.Quantity?>? field_VectorOptional;
        IReadOnlyList<LabApps.Units.Quantity?>? IBasic_Quantity.VectorOptional => field_VectorOptional;
        public ImmutableList<LabApps.Units.Quantity?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = value;
        }
        private ImmutableDictionary<String, LabApps.Units.Quantity>? field_MapRequired;
        IReadOnlyDictionary<String, LabApps.Units.Quantity>? IBasic_Quantity.MapRequired => MapRequired;
        public ImmutableDictionary<String, LabApps.Units.Quantity>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = value;
        }
        private ImmutableDictionary<String, LabApps.Units.Quantity?>? field_MapOptional;
        IReadOnlyDictionary<String, LabApps.Units.Quantity?>? IBasic_Quantity.MapOptional => field_MapOptional;
        public ImmutableDictionary<String, LabApps.Units.Quantity?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Quantity() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Quantity(Basic_Quantity? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired;
            field_VectorOptional = source.VectorOptional;
            field_MapRequired = source.MapRequired;
            field_MapOptional = source.MapOptional;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Quantity(IBasic_Quantity? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<LabApps.Units.Quantity>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<LabApps.Units.Quantity?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, LabApps.Units.Quantity>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, LabApps.Units.Quantity?>.Empty.AddRange(source.MapOptional);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_Quantity? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_ScalarRequired = source.ScalarRequired;
            field_ScalarOptional = source.ScalarOptional;
            field_VectorRequired = source.VectorRequired is null
                ? default
                : ImmutableList<LabApps.Units.Quantity>.Empty.AddRange(source.VectorRequired);
            field_VectorOptional = source.VectorOptional is null
                ? default
                : ImmutableList<LabApps.Units.Quantity?>.Empty.AddRange(source.VectorOptional);
            field_MapRequired = source.MapRequired is null
                ? default
                : ImmutableDictionary<String, LabApps.Units.Quantity>.Empty.AddRange(source.MapRequired);
            field_MapOptional = source.MapOptional is null
                ? default
                : ImmutableDictionary<String, LabApps.Units.Quantity?>.Empty.AddRange(source.MapOptional);
        }

        public bool Equals(Basic_Quantity? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (ScalarRequired != other.ScalarRequired) return false;
            if (ScalarOptional != other.ScalarOptional) return false;
            if (!VectorRequired.ArrayEquals(other.VectorRequired, (a, b) => a == b)) return false;
            if (!VectorOptional.ArrayEquals(other.VectorOptional, (a, b) => a == b)) return false;
            if (!MapRequired.IndexEquals(other.MapRequired, (a, b) => a == b)) return false;
            if (!MapOptional.IndexEquals(other.MapOptional, (a, b) => a == b)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_Quantity other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(ScalarRequired.CalcHashUnary());
            hc.Add(ScalarOptional.CalcHashUnary());
            hc.Add(VectorRequired.CalcHashArray());
            hc.Add(VectorOptional.CalcHashArray());
            hc.Add(MapRequired.CalcHashIndex());
            hc.Add(MapOptional.CalcHashIndex());
            return hc.ToHashCode();
        }
    }

    public partial class Basic_string
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_string? CreateFrom(IBasic_string? source)
        {
            if (source is null) return null;
            return new Basic_string(source);
        }

        private static Basic_string CreateEmpty()
        {
            var empty = new Basic_string();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_string _empty = CreateEmpty();
        public static new Basic_string Empty => _empty;

    }
    public partial class Basic_string : EntityBase, IBasic_string, IEquatable<Basic_string>
    {
        public new const int EntityTag = 30;
        protected override int OnGetEntityTag() => EntityTag;

        private String? field_Scalar;
        String? IBasic_string.Scalar => field_Scalar;
        public String? Scalar
        {
            get => field_Scalar;
            set => field_Scalar = value;
        }
        private ImmutableList<String?>? field_Vector;
        IReadOnlyList<String?>? IBasic_string.Vector => field_Vector;
        public ImmutableList<String?>? Vector
        {
            get => field_Vector;
            set => field_Vector = value;
        }
        private ImmutableDictionary<String, String?>? field_MapValue;
        IReadOnlyDictionary<String, String?>? IBasic_string.MapValue => field_MapValue;
        public ImmutableDictionary<String, String?>? MapValue
        {
            get => field_MapValue;
            set => field_MapValue = value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_string() : base()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_string(Basic_string? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Scalar = source.Scalar;
            field_Vector = source.Vector;
            field_MapValue = source.MapValue;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_string(IBasic_string? source) : base(source)
        {
            if (source is null) throw new ArgumentNullException(nameof(source));
            field_Scalar = source.Scalar;
            field_Vector = source.Vector is null
                ? default
                : ImmutableList<String?>.Empty.AddRange(source.Vector);
            field_MapValue = source.MapValue is null
                ? default
                : ImmutableDictionary<String, String?>.Empty.AddRange(source.MapValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void CopyFrom(IBasic_string? source)
        {
            if (source is null) return;
            base.CopyFrom(source);
            field_Scalar = source.Scalar;
            field_Vector = source.Vector is null
                ? default
                : ImmutableList<String?>.Empty.AddRange(source.Vector);
            field_MapValue = source.MapValue is null
                ? default
                : ImmutableDictionary<String, String?>.Empty.AddRange(source.MapValue);
        }

        public bool Equals(Basic_string? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!base.Equals(other)) return false;
            if (!Scalar.ValueEquals(other.Scalar)) return false;
            if (!Vector.ArrayEquals(other.Vector)) return false;
            if (!MapValue.IndexEquals(other.MapValue)) return false;
            return true;
        }

        public override bool Equals(object? obj) => obj is Basic_string other && Equals(other);

        public override int GetHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(base.GetHashCode());
            hc.Add(Scalar.CalcHashUnary());
            hc.Add(Vector.CalcHashArray());
            hc.Add(MapValue.CalcHashIndex());
            return hc.ToHashCode();
        }
    }


}

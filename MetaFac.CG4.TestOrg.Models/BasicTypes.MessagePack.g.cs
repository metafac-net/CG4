#region Notices
// <auto-generated>
// Warning: This file was automatically generated. Changes to this file may
// cause incorrect behavior and will be lost when this file is regenerated.
// </auto-generated>
// <information>
// This file was generated using MetaFac.CG4 tools and user supplied metadata.
// Generator: MessagePack.2.1
// Metadata : MetaFac.CG4.TestOrg.Schema(.BasicTypes)
// </information>
#endregion
#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
#pragma warning disable CS8019 // Unnecessary using directive
#pragma warning disable CS8019 // Unnecessary using directive
using MetaFac.Memory;
using MetaFac.Mutability;
using MessagePack;
using MetaFac.CG4.Runtime;
using MetaFac.CG4.Runtime.MessagePack;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Runtime.CompilerServices;
using MetaFac.CG4.TestOrg.Models.BasicTypes.Contracts;

namespace MetaFac.CG4.TestOrg.Models.BasicTypes.MessagePack
{


    public abstract class EntityBase : IFreezable, IEntityBase, IEquatable<EntityBase>, ICopyFrom<EntityBase>
    {
        public static EntityBase Empty => throw new NotSupportedException();
        public const int EntityTag = 0;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static void ThrowIsReadonly()
        {
            throw new InvalidOperationException("Cannot set properties when frozen");
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected ref T CheckNotFrozen<T>(ref T value)
        {
            if (_isFrozen) ThrowIsReadonly();
            return ref value;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        protected void CheckNotFrozen()
        {
            if (_isFrozen) ThrowIsReadonly();
        }

        public EntityBase() { }
        public EntityBase(EntityBase source) { }
        public void CopyFrom(EntityBase source)
        {
            CheckNotFrozen();
        }
        public EntityBase(IEntityBase source) { }
        protected abstract int OnGetEntityTag();
        public int GetEntityTag() => OnGetEntityTag();

        protected volatile bool _isFrozen = false;
        public bool IsFreezable() => true;
        public bool IsFrozen() => _isFrozen;
        protected virtual void OnFreeze() { }
        public void Freeze()
        {
            if (_isFrozen) return;
            OnFreeze();
            _isFrozen = true;
        }
        public bool TryFreeze()
        {
            if (_isFrozen) return false;
            OnFreeze();
            _isFrozen = true;
            return true;
        }

        public bool Equals(EntityBase? other) => true;
        public override bool Equals(object? obj) => obj is EntityBase other && this.Equals(other);
        public override int GetHashCode() => 0;
    }


    public partial class Basic_bool
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_bool? CreateFrom(IBasic_bool? source)
        {
            if (source is null) return null;
            return new Basic_bool(source);
        }

        private static Basic_bool CreateEmpty()
        {
            var empty = new Basic_bool();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_bool _empty = CreateEmpty();
        public static new Basic_bool Empty => _empty;

    }
    [MessagePackObject]
    public partial class Basic_bool : EntityBase, IBasic_bool, IEquatable<Basic_bool>, ICopyFrom<Basic_bool>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 1;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private Boolean field_ScalarRequired;
        private Boolean? field_ScalarOptional;
        private ImmutableList<Boolean>? field_VectorRequired;
        private ImmutableList<Boolean?>? field_VectorOptional;
        private ImmutableDictionary<String, Boolean>? field_MapRequired;
        private ImmutableDictionary<String, Boolean?>? field_MapOptional;
        private ImmutableDictionary<Boolean, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public Boolean ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public Boolean? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<Boolean>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<Boolean?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, Boolean>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, Boolean?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Boolean, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_bool methods ----------
        Boolean IBasic_bool.ScalarRequired => field_ScalarRequired.ToExternal();
        Boolean? IBasic_bool.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Boolean>? IBasic_bool.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Boolean, Boolean>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Boolean?>? IBasic_bool.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Boolean?, Boolean?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Boolean>? IBasic_bool.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Boolean, Boolean>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Boolean?>? IBasic_bool.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Boolean?, Boolean?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Boolean, String?>? IBasic_bool.MapKey => field_MapKey;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_bool()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_bool(Basic_bool source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_bool source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_bool(IBasic_bool source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<Boolean>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<Boolean?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, Boolean>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, Boolean>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, Boolean?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, Boolean?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Boolean, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_bool? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (field_ScalarRequired != other.field_ScalarRequired) return false;
            if (field_ScalarOptional != other.field_ScalarOptional) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired, (a, b) => a == b)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional, (a, b) => a == b)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired, (a, b) => a == b)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional, (a, b) => a == b)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Basic_bool left, Basic_bool right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Basic_bool left, Basic_bool right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj)
        {
            return obj is Basic_bool other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public partial class Basic_decimal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_decimal? CreateFrom(IBasic_decimal? source)
        {
            if (source is null) return null;
            return new Basic_decimal(source);
        }

        private static Basic_decimal CreateEmpty()
        {
            var empty = new Basic_decimal();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_decimal _empty = CreateEmpty();
        public static new Basic_decimal Empty => _empty;

    }
    [MessagePackObject]
    public partial class Basic_decimal : EntityBase, IBasic_decimal, IEquatable<Basic_decimal>, ICopyFrom<Basic_decimal>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 17;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private DecimalValue field_ScalarRequired;
        private DecimalValue? field_ScalarOptional;
        private ImmutableList<DecimalValue>? field_VectorRequired;
        private ImmutableList<DecimalValue?>? field_VectorOptional;
        private ImmutableDictionary<String, DecimalValue>? field_MapRequired;
        private ImmutableDictionary<String, DecimalValue?>? field_MapOptional;
        private ImmutableDictionary<Decimal, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public DecimalValue ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public DecimalValue? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<DecimalValue>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<DecimalValue?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, DecimalValue>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, DecimalValue?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Decimal, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_decimal methods ----------
        Decimal IBasic_decimal.ScalarRequired => field_ScalarRequired.ToExternal();
        Decimal? IBasic_decimal.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Decimal>? IBasic_decimal.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Decimal, DecimalValue>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Decimal?>? IBasic_decimal.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Decimal?, DecimalValue?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Decimal>? IBasic_decimal.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Decimal, DecimalValue>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Decimal?>? IBasic_decimal.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Decimal?, DecimalValue?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Decimal, String?>? IBasic_decimal.MapKey => field_MapKey;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_decimal()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_decimal(Basic_decimal source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_decimal source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_decimal(IBasic_decimal source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<DecimalValue>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<DecimalValue?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, DecimalValue>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, DecimalValue>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, DecimalValue?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, DecimalValue?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Decimal, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_decimal? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (field_ScalarRequired != other.field_ScalarRequired) return false;
            if (field_ScalarOptional != other.field_ScalarOptional) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired, (a, b) => a == b)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional, (a, b) => a == b)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired, (a, b) => a == b)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional, (a, b) => a == b)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Basic_decimal left, Basic_decimal right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Basic_decimal left, Basic_decimal right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj)
        {
            return obj is Basic_decimal other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public partial class Basic_DateTimeOffset
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_DateTimeOffset? CreateFrom(IBasic_DateTimeOffset? source)
        {
            if (source is null) return null;
            return new Basic_DateTimeOffset(source);
        }

        private static Basic_DateTimeOffset CreateEmpty()
        {
            var empty = new Basic_DateTimeOffset();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_DateTimeOffset _empty = CreateEmpty();
        public static new Basic_DateTimeOffset Empty => _empty;

    }
    [MessagePackObject]
    public partial class Basic_DateTimeOffset : EntityBase, IBasic_DateTimeOffset, IEquatable<Basic_DateTimeOffset>, ICopyFrom<Basic_DateTimeOffset>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 18;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private DateTimeOffsetValue field_ScalarRequired;
        private DateTimeOffsetValue? field_ScalarOptional;
        private ImmutableList<DateTimeOffsetValue>? field_VectorRequired;
        private ImmutableList<DateTimeOffsetValue?>? field_VectorOptional;
        private ImmutableDictionary<String, DateTimeOffsetValue>? field_MapRequired;
        private ImmutableDictionary<String, DateTimeOffsetValue?>? field_MapOptional;
        private ImmutableDictionary<DateTimeOffset, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public DateTimeOffsetValue ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public DateTimeOffsetValue? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<DateTimeOffsetValue>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<DateTimeOffsetValue?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, DateTimeOffsetValue>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, DateTimeOffsetValue?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<DateTimeOffset, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_DateTimeOffset methods ----------
        DateTimeOffset IBasic_DateTimeOffset.ScalarRequired => field_ScalarRequired.ToExternal();
        DateTimeOffset? IBasic_DateTimeOffset.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<DateTimeOffset>? IBasic_DateTimeOffset.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<DateTimeOffset, DateTimeOffsetValue>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<DateTimeOffset?>? IBasic_DateTimeOffset.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<DateTimeOffset?, DateTimeOffsetValue?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, DateTimeOffset>? IBasic_DateTimeOffset.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, DateTimeOffset, DateTimeOffsetValue>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, DateTimeOffset?>? IBasic_DateTimeOffset.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, DateTimeOffset?, DateTimeOffsetValue?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<DateTimeOffset, String?>? IBasic_DateTimeOffset.MapKey => field_MapKey;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DateTimeOffset()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DateTimeOffset(Basic_DateTimeOffset source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_DateTimeOffset source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DateTimeOffset(IBasic_DateTimeOffset source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<DateTimeOffsetValue>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<DateTimeOffsetValue?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, DateTimeOffsetValue>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, DateTimeOffsetValue>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, DateTimeOffsetValue?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, DateTimeOffsetValue?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<DateTimeOffset, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_DateTimeOffset? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (field_ScalarRequired != other.field_ScalarRequired) return false;
            if (field_ScalarOptional != other.field_ScalarOptional) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired, (a, b) => a == b)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional, (a, b) => a == b)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired, (a, b) => a == b)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional, (a, b) => a == b)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Basic_DateTimeOffset left, Basic_DateTimeOffset right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Basic_DateTimeOffset left, Basic_DateTimeOffset right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj)
        {
            return obj is Basic_DateTimeOffset other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public partial class Basic_Guid
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_Guid? CreateFrom(IBasic_Guid? source)
        {
            if (source is null) return null;
            return new Basic_Guid(source);
        }

        private static Basic_Guid CreateEmpty()
        {
            var empty = new Basic_Guid();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_Guid _empty = CreateEmpty();
        public static new Basic_Guid Empty => _empty;

    }
    [MessagePackObject]
    public partial class Basic_Guid : EntityBase, IBasic_Guid, IEquatable<Basic_Guid>, ICopyFrom<Basic_Guid>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 19;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private GuidValue field_ScalarRequired;
        private GuidValue? field_ScalarOptional;
        private ImmutableList<GuidValue>? field_VectorRequired;
        private ImmutableList<GuidValue?>? field_VectorOptional;
        private ImmutableDictionary<String, GuidValue>? field_MapRequired;
        private ImmutableDictionary<String, GuidValue?>? field_MapOptional;
        private ImmutableDictionary<Guid, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public GuidValue ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public GuidValue? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<GuidValue>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<GuidValue?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, GuidValue>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, GuidValue?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<Guid, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_Guid methods ----------
        Guid IBasic_Guid.ScalarRequired => field_ScalarRequired.ToExternal();
        Guid? IBasic_Guid.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<Guid>? IBasic_Guid.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<Guid, GuidValue>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<Guid?>? IBasic_Guid.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<Guid?, GuidValue?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Guid>? IBasic_Guid.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, Guid, GuidValue>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, Guid?>? IBasic_Guid.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, Guid?, GuidValue?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<Guid, String?>? IBasic_Guid.MapKey => field_MapKey;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Guid()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Guid(Basic_Guid source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_Guid source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Guid(IBasic_Guid source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<GuidValue>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<GuidValue?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, GuidValue>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, GuidValue>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, GuidValue?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, GuidValue?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<Guid, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_Guid? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (field_ScalarRequired != other.field_ScalarRequired) return false;
            if (field_ScalarOptional != other.field_ScalarOptional) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired, (a, b) => a == b)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional, (a, b) => a == b)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired, (a, b) => a == b)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional, (a, b) => a == b)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Basic_Guid left, Basic_Guid right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Basic_Guid left, Basic_Guid right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj)
        {
            return obj is Basic_Guid other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public partial class Basic_DayOfWeek
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_DayOfWeek? CreateFrom(IBasic_DayOfWeek? source)
        {
            if (source is null) return null;
            return new Basic_DayOfWeek(source);
        }

        private static Basic_DayOfWeek CreateEmpty()
        {
            var empty = new Basic_DayOfWeek();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_DayOfWeek _empty = CreateEmpty();
        public static new Basic_DayOfWeek Empty => _empty;

    }
    [MessagePackObject]
    public partial class Basic_DayOfWeek : EntityBase, IBasic_DayOfWeek, IEquatable<Basic_DayOfWeek>, ICopyFrom<Basic_DayOfWeek>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 20;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private System.DayOfWeek field_ScalarRequired;
        private System.DayOfWeek? field_ScalarOptional;
        private ImmutableList<System.DayOfWeek>? field_VectorRequired;
        private ImmutableList<System.DayOfWeek?>? field_VectorOptional;
        private ImmutableDictionary<String, System.DayOfWeek>? field_MapRequired;
        private ImmutableDictionary<String, System.DayOfWeek?>? field_MapOptional;
        private ImmutableDictionary<System.DayOfWeek, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public System.DayOfWeek ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public System.DayOfWeek? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<System.DayOfWeek>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<System.DayOfWeek?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, System.DayOfWeek>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, System.DayOfWeek?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<System.DayOfWeek, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_DayOfWeek methods ----------
        System.DayOfWeek IBasic_DayOfWeek.ScalarRequired => field_ScalarRequired.ToExternal();
        System.DayOfWeek? IBasic_DayOfWeek.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<System.DayOfWeek>? IBasic_DayOfWeek.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<System.DayOfWeek, System.DayOfWeek>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<System.DayOfWeek?>? IBasic_DayOfWeek.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<System.DayOfWeek?, System.DayOfWeek?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, System.DayOfWeek>? IBasic_DayOfWeek.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, System.DayOfWeek, System.DayOfWeek>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, System.DayOfWeek?>? IBasic_DayOfWeek.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, System.DayOfWeek?, System.DayOfWeek?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<System.DayOfWeek, String?>? IBasic_DayOfWeek.MapKey => field_MapKey;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DayOfWeek()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DayOfWeek(Basic_DayOfWeek source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_DayOfWeek source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_DayOfWeek(IBasic_DayOfWeek source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<System.DayOfWeek>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<System.DayOfWeek?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, System.DayOfWeek>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, System.DayOfWeek>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, System.DayOfWeek?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, System.DayOfWeek?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<System.DayOfWeek, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_DayOfWeek? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (field_ScalarRequired != other.field_ScalarRequired) return false;
            if (field_ScalarOptional != other.field_ScalarOptional) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired, (a, b) => a == b)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional, (a, b) => a == b)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired, (a, b) => a == b)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional, (a, b) => a == b)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Basic_DayOfWeek left, Basic_DayOfWeek right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Basic_DayOfWeek left, Basic_DayOfWeek right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj)
        {
            return obj is Basic_DayOfWeek other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public partial class Basic_MyCustomEnum
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_MyCustomEnum? CreateFrom(IBasic_MyCustomEnum? source)
        {
            if (source is null) return null;
            return new Basic_MyCustomEnum(source);
        }

        private static Basic_MyCustomEnum CreateEmpty()
        {
            var empty = new Basic_MyCustomEnum();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_MyCustomEnum _empty = CreateEmpty();
        public static new Basic_MyCustomEnum Empty => _empty;

    }
    [MessagePackObject]
    public partial class Basic_MyCustomEnum : EntityBase, IBasic_MyCustomEnum, IEquatable<Basic_MyCustomEnum>, ICopyFrom<Basic_MyCustomEnum>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 21;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private MyCustomEnum field_ScalarRequired;
        private MyCustomEnum? field_ScalarOptional;
        private ImmutableList<MyCustomEnum>? field_VectorRequired;
        private ImmutableList<MyCustomEnum?>? field_VectorOptional;
        private ImmutableDictionary<String, MyCustomEnum>? field_MapRequired;
        private ImmutableDictionary<String, MyCustomEnum?>? field_MapOptional;
        private ImmutableDictionary<MyCustomEnum, String?>? field_MapKey;

        // ---------- accessors ----------
        [Key(1)]
        public MyCustomEnum ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public MyCustomEnum? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<MyCustomEnum>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<MyCustomEnum?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, MyCustomEnum>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, MyCustomEnum?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }
        [Key(7)]
        public ImmutableDictionary<MyCustomEnum, String?>? MapKey
        {
            get => field_MapKey;
            set => field_MapKey = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_MyCustomEnum methods ----------
        MyCustomEnum IBasic_MyCustomEnum.ScalarRequired => field_ScalarRequired.ToExternal();
        MyCustomEnum? IBasic_MyCustomEnum.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<MyCustomEnum>? IBasic_MyCustomEnum.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<MyCustomEnum, MyCustomEnum>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<MyCustomEnum?>? IBasic_MyCustomEnum.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<MyCustomEnum?, MyCustomEnum?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, MyCustomEnum>? IBasic_MyCustomEnum.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, MyCustomEnum, MyCustomEnum>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, MyCustomEnum?>? IBasic_MyCustomEnum.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, MyCustomEnum?, MyCustomEnum?>(field_MapOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<MyCustomEnum, String?>? IBasic_MyCustomEnum.MapKey => field_MapKey;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_MyCustomEnum()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_MyCustomEnum(Basic_MyCustomEnum source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        public void CopyFrom(Basic_MyCustomEnum source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
            field_MapKey = source.field_MapKey;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_MyCustomEnum(IBasic_MyCustomEnum source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<MyCustomEnum>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<MyCustomEnum?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, MyCustomEnum>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, MyCustomEnum>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, MyCustomEnum?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, MyCustomEnum?>(kvp.Key, kvp.Value.ToInternal())));
            field_MapKey = source.MapKey is null
                ? null
                : ImmutableDictionary<MyCustomEnum, String?>.Empty.AddRange(source.MapKey);
        }

        public bool Equals(Basic_MyCustomEnum? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (field_ScalarRequired != other.field_ScalarRequired) return false;
            if (field_ScalarOptional != other.field_ScalarOptional) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired, (a, b) => a == b)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional, (a, b) => a == b)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired, (a, b) => a == b)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional, (a, b) => a == b)) return false;
            if (!field_MapKey.IndexEquals(other.field_MapKey)) return false;
            return base.Equals(other);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Basic_MyCustomEnum left, Basic_MyCustomEnum right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Basic_MyCustomEnum left, Basic_MyCustomEnum right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj)
        {
            return obj is Basic_MyCustomEnum other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(field_MapKey.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public partial class Basic_Quantity
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_Quantity? CreateFrom(IBasic_Quantity? source)
        {
            if (source is null) return null;
            return new Basic_Quantity(source);
        }

        private static Basic_Quantity CreateEmpty()
        {
            var empty = new Basic_Quantity();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_Quantity _empty = CreateEmpty();
        public static new Basic_Quantity Empty => _empty;

    }
    [MessagePackObject]
    public partial class Basic_Quantity : EntityBase, IBasic_Quantity, IEquatable<Basic_Quantity>, ICopyFrom<Basic_Quantity>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 22;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private QuantityValue field_ScalarRequired;
        private QuantityValue? field_ScalarOptional;
        private ImmutableList<QuantityValue>? field_VectorRequired;
        private ImmutableList<QuantityValue?>? field_VectorOptional;
        private ImmutableDictionary<String, QuantityValue>? field_MapRequired;
        private ImmutableDictionary<String, QuantityValue?>? field_MapOptional;

        // ---------- accessors ----------
        [Key(1)]
        public QuantityValue ScalarRequired
        {
            get => field_ScalarRequired;
            set => field_ScalarRequired = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public QuantityValue? ScalarOptional
        {
            get => field_ScalarOptional;
            set => field_ScalarOptional = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableList<QuantityValue>? VectorRequired
        {
            get => field_VectorRequired;
            set => field_VectorRequired = CheckNotFrozen(ref value);
        }
        [Key(4)]
        public ImmutableList<QuantityValue?>? VectorOptional
        {
            get => field_VectorOptional;
            set => field_VectorOptional = CheckNotFrozen(ref value);
        }
        [Key(5)]
        public ImmutableDictionary<String, QuantityValue>? MapRequired
        {
            get => field_MapRequired;
            set => field_MapRequired = CheckNotFrozen(ref value);
        }
        [Key(6)]
        public ImmutableDictionary<String, QuantityValue?>? MapOptional
        {
            get => field_MapOptional;
            set => field_MapOptional = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_Quantity methods ----------
        LabApps.Units.Quantity IBasic_Quantity.ScalarRequired => field_ScalarRequired.ToExternal();
        LabApps.Units.Quantity? IBasic_Quantity.ScalarOptional => field_ScalarOptional.ToExternal();
        IReadOnlyList<LabApps.Units.Quantity>? IBasic_Quantity.VectorRequired
            => field_VectorRequired is null ? null
            : new ListFacade<LabApps.Units.Quantity, QuantityValue>(field_VectorRequired, (x) => x.ToExternal());
        IReadOnlyList<LabApps.Units.Quantity?>? IBasic_Quantity.VectorOptional
            => field_VectorOptional is null ? null
            : new ListFacade<LabApps.Units.Quantity?, QuantityValue?>(field_VectorOptional, (x) => x.ToExternal());
        IReadOnlyDictionary<String, LabApps.Units.Quantity>? IBasic_Quantity.MapRequired
            => field_MapRequired is null ? null
            : new DictionaryFacade<String, LabApps.Units.Quantity, QuantityValue>(field_MapRequired, (x) => x.ToExternal());
        IReadOnlyDictionary<String, LabApps.Units.Quantity?>? IBasic_Quantity.MapOptional
            => field_MapOptional is null ? null
            : new DictionaryFacade<String, LabApps.Units.Quantity?, QuantityValue?>(field_MapOptional, (x) => x.ToExternal());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Quantity()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Quantity(Basic_Quantity source) : base(source)
        {
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
        }

        public void CopyFrom(Basic_Quantity source)
        {
            base.CopyFrom(source);
            field_ScalarRequired = source.field_ScalarRequired;
            field_ScalarOptional = source.field_ScalarOptional;
            field_VectorRequired = source.field_VectorRequired;
            field_VectorOptional = source.field_VectorOptional;
            field_MapRequired = source.field_MapRequired;
            field_MapOptional = source.field_MapOptional;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_Quantity(IBasic_Quantity source) : base(source)
        {
            field_ScalarRequired = source.ScalarRequired.ToInternal();
            field_ScalarOptional = source.ScalarOptional.ToInternal();
            field_VectorRequired = source.VectorRequired is null
                ? null
                : ImmutableList<QuantityValue>.Empty.AddRange(source.VectorRequired.Select(x => x.ToInternal()));
            field_VectorOptional = source.VectorOptional is null
                ? null
                : ImmutableList<QuantityValue?>.Empty.AddRange(source.VectorOptional.Select(x => x.ToInternal()));
            field_MapRequired = source.MapRequired is null
                ? null
                : ImmutableDictionary<String, QuantityValue>.Empty.AddRange(source.MapRequired.Select(
                    kvp => new KeyValuePair<String, QuantityValue>(kvp.Key, kvp.Value.ToInternal())));
            field_MapOptional = source.MapOptional is null
                ? null
                : ImmutableDictionary<String, QuantityValue?>.Empty.AddRange(source.MapOptional.Select(
                    kvp => new KeyValuePair<String, QuantityValue?>(kvp.Key, kvp.Value.ToInternal())));
        }

        public bool Equals(Basic_Quantity? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (field_ScalarRequired != other.field_ScalarRequired) return false;
            if (field_ScalarOptional != other.field_ScalarOptional) return false;
            if (!field_VectorRequired.ArrayEquals(other.field_VectorRequired, (a, b) => a == b)) return false;
            if (!field_VectorOptional.ArrayEquals(other.field_VectorOptional, (a, b) => a == b)) return false;
            if (!field_MapRequired.IndexEquals(other.field_MapRequired, (a, b) => a == b)) return false;
            if (!field_MapOptional.IndexEquals(other.field_MapOptional, (a, b) => a == b)) return false;
            return base.Equals(other);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Basic_Quantity left, Basic_Quantity right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Basic_Quantity left, Basic_Quantity right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj)
        {
            return obj is Basic_Quantity other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_ScalarRequired.CalcHashUnary());
            hc.Add(field_ScalarOptional.CalcHashUnary());
            hc.Add(field_VectorRequired.CalcHashArray());
            hc.Add(field_VectorOptional.CalcHashArray());
            hc.Add(field_MapRequired.CalcHashIndex());
            hc.Add(field_MapOptional.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }

    public partial class Basic_string
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Basic_string? CreateFrom(IBasic_string? source)
        {
            if (source is null) return null;
            return new Basic_string(source);
        }

        private static Basic_string CreateEmpty()
        {
            var empty = new Basic_string();
            empty.Freeze();
            return empty;
        }
        private static readonly Basic_string _empty = CreateEmpty();
        public static new Basic_string Empty => _empty;

    }
    [MessagePackObject]
    public partial class Basic_string : EntityBase, IBasic_string, IEquatable<Basic_string>, ICopyFrom<Basic_string>
    {
        protected override void OnFreeze()
        {
            base.OnFreeze();
        }

        public new const int EntityTag = 30;
        protected override int OnGetEntityTag() => EntityTag;

        // ---------- private fields ----------
        private String? field_Scalar;
        private ImmutableList<String?>? field_Vector;
        private ImmutableDictionary<String, String?>? field_MapValue;

        // ---------- accessors ----------
        [Key(1)]
        public String? Scalar
        {
            get => field_Scalar;
            set => field_Scalar = CheckNotFrozen(ref value);
        }
        [Key(2)]
        public ImmutableList<String?>? Vector
        {
            get => field_Vector;
            set => field_Vector = CheckNotFrozen(ref value);
        }
        [Key(3)]
        public ImmutableDictionary<String, String?>? MapValue
        {
            get => field_MapValue;
            set => field_MapValue = CheckNotFrozen(ref value);
        }

        // ---------- IBasic_string methods ----------
        String? IBasic_string.Scalar => field_Scalar;
        IReadOnlyList<String?>? IBasic_string.Vector => field_Vector;
        IReadOnlyDictionary<String, String?>? IBasic_string.MapValue => field_MapValue;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_string()
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_string(Basic_string source) : base(source)
        {
            field_Scalar = source.field_Scalar;
            field_Vector = source.field_Vector;
            field_MapValue = source.field_MapValue;
        }

        public void CopyFrom(Basic_string source)
        {
            base.CopyFrom(source);
            field_Scalar = source.field_Scalar;
            field_Vector = source.field_Vector;
            field_MapValue = source.field_MapValue;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Basic_string(IBasic_string source) : base(source)
        {
            field_Scalar = source.Scalar;
            field_Vector = source.Vector is null
                ? null
                : ImmutableList<String?>.Empty.AddRange(source.Vector);
            field_MapValue = source.MapValue is null
                ? null
                : ImmutableDictionary<String, String?>.Empty.AddRange(source.MapValue);
        }

        public bool Equals(Basic_string? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(other, this)) return true;
            if (!field_Scalar.ValueEquals(other.field_Scalar)) return false;
            if (!field_Vector.ArrayEquals(other.field_Vector)) return false;
            if (!field_MapValue.IndexEquals(other.field_MapValue)) return false;
            return base.Equals(other);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Basic_string left, Basic_string right)
        {
            if (left is null) return (right is null);
            return left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Basic_string left, Basic_string right)
        {
            if (left is null) return !(right is null);
            return !left.Equals(right);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj)
        {
            return obj is Basic_string other && Equals(other);
        }

        private int CalcHashCode()
        {
            HashCode hc = new HashCode();
            hc.Add(field_Scalar.CalcHashUnary());
            hc.Add(field_Vector.CalcHashArray());
            hc.Add(field_MapValue.CalcHashIndex());
            hc.Add(base.GetHashCode());
            return hc.ToHashCode();
        }

        private int? _hashCode = null;
        public override int GetHashCode()
        {
            if (!_isFrozen) return CalcHashCode();
            if (_hashCode is null)
                _hashCode = CalcHashCode();
            return _hashCode.Value;
        }

    }


}
